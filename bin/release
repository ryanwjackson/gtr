#!/usr/bin/env bash
set -euo pipefail

# Function to get the latest version tag from git
get_current_version() {
  # Get the latest tag that looks like a version (vX.Y.Z)
  local latest_tag
  latest_tag=$(git tag -l 'v*.*.*' --sort=-version:refname | head -n1)
  if [[ -z "$latest_tag" ]]; then
    echo "v0.0.0"  # Default if no version tags exist
  else
    echo "$latest_tag"
  fi
}

# Function to bump version based on type
bump_version() {
  local current_version="$1"
  local bump_type="$2"

  # Remove 'v' prefix for processing
  local version_numbers="${current_version#v}"

  # Split into major.minor.patch
  local major minor patch
  IFS='.' read -r major minor patch <<< "$version_numbers"

  case "$bump_type" in
    major)
      major=$((major + 1))
      minor=0
      patch=0
      ;;
    minor)
      minor=$((minor + 1))
      patch=0
      ;;
    patch)
      patch=$((patch + 1))
      ;;
    *)
      echo "Error: Invalid bump type: $bump_type" >&2
      exit 1
      ;;
  esac

  echo "v$major.$minor.$patch"
}

usage() {
  cat <<'USAGE'
Usage: bin/release [options] <version>

Create a GitHub Release for the given version.

Arguments:
  version              Semver like 1.2.3 or v1.2.3, or bump keyword (major, minor, patch).
                       The leading "v" will be added if missing for explicit versions.
                       Bump keywords will increment the latest git tag version.

Options:
  -m, --message <msg>  Release notes/title message. Defaults to the normalized version string.
  -f, --force          Allow using an existing tag (locally or on remote).
  -h, --help           Show this help.

Environment:
  Requires GitHub CLI (gh) authenticated to your repo (gh auth status).

Behavior:
  - Normalizes the tag to start with 'v' (e.g., 1.2.3 -> v1.2.3).
  - Creates an annotated git tag locally if missing, pushes it to the remote.
  - Creates a GitHub Release for the tag if it does not already exist.
  - Fails if the tag already exists locally or remotely unless --force is provided.

Examples:
  # Simple release with explicit version
  bin/release 0.1.2

  # Explicit tag format is also accepted
  bin/release v0.1.2

  # Bump patch version from current (e.g., v1.2.3 -> v1.2.4)
  bin/release patch

  # Bump minor version from current (e.g., v1.2.3 -> v1.3.0)
  bin/release minor

  # Bump major version from current (e.g., v1.2.3 -> v2.0.0)
  bin/release major

  # Provide custom release notes/title
  bin/release patch -m "Bugfixes and improvements"
USAGE
}

message=""
version=""
force=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -m|--message)
      shift
      [[ $# -gt 0 ]] || { echo "Error: --message requires an argument" >&2; exit 1; }
      message="$1"
      shift
      ;;
    -h|--help)
      usage; exit 0
      ;;
    -f|--force)
      force=true
      shift
      ;;
    --)
      shift; break
      ;;
    -*)
      echo "Unknown option: $1" >&2
      usage; exit 1
      ;;
    *)
      if [[ -z "$version" ]]; then
        version="$1"
        shift
      else
        echo "Unexpected extra argument: $1" >&2
        usage; exit 1
      fi
      ;;
  esac
done

if [[ -z "$version" ]]; then
  echo "Error: version is required" >&2
  usage
  exit 1
fi

# Handle semantic version keywords or explicit versions
if [[ "$version" =~ ^(major|minor|patch)$ ]]; then
  # Get current version and bump it
  current_version=$(get_current_version)
  tag=$(bump_version "$current_version" "$version")
  echo "Bumping $version from $current_version to $tag"
else
  # Normalize explicit version to start with 'v'
  if [[ "$version" != v* ]]; then
    tag="v$version"
  else
    tag="$version"
  fi

  # Basic semver validation (vMAJOR.MINOR.PATCH)
  if ! [[ "$tag" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo "Error: version must be semantic version (e.g., 1.2.3 or v1.2.3) or bump keyword (major, minor, patch)" >&2
    exit 1
  fi
fi

notes="${message:-$tag}"

# Ensure gh is available and authenticated
if ! command -v gh >/dev/null 2>&1; then
  echo "Error: GitHub CLI 'gh' not found. Install from https://cli.github.com/" >&2
  exit 1
fi
if ! gh auth status >/dev/null 2>&1; then
  echo "Error: gh is not authenticated. Run 'gh auth login' or set GH_TOKEN." >&2
  exit 1
fi

# Ensure git is available
if ! command -v git >/dev/null 2>&1; then
  echo "Error: git not found" >&2
  exit 1
fi

# Require a clean working tree (no uncommitted or untracked changes)
if [[ -n "$(git status --porcelain)" ]]; then
  echo "Error: working tree has uncommitted changes. Commit or stash before releasing." >&2
  git status --short || true
  exit 1
fi

# Determine default remote
remote="origin"
if ! git remote get-url "$remote" >/dev/null 2>&1; then
  # Fallback to first remote, if any
  if first_remote=$(git remote | head -n1); then
    remote="$first_remote"
  else
    echo "Error: no git remote configured" >&2
    exit 1
  fi
fi

# Ensure the current branch is pushed before creating the release/tag
current_branch="$(git rev-parse --abbrev-ref HEAD)"
if [[ "$current_branch" != "HEAD" ]]; then
  echo "Pushing local commits on branch $current_branch to $remote"
  if git rev-parse --verify "@{u}" >/dev/null 2>&1; then
    git push "$remote" "$current_branch"
  else
    echo "No upstream for $current_branch. Setting upstream to $remote/$current_branch"
    git push -u "$remote" "$current_branch"
  fi
else
  echo "Detached HEAD; skipping branch push"
fi

## Tag existence checks
local_exists=false
remote_exists=false
if git rev-parse "$tag" >/dev/null 2>&1; then
  local_exists=true
fi
if git ls-remote --tags "$remote" "$tag" | grep -q "$tag"; then
  remote_exists=true
fi

if [[ "$local_exists" == true || "$remote_exists" == true ]]; then
  if [[ "$force" != true ]]; then
    echo "Error: tag $tag already exists (local: $local_exists, remote: $remote_exists). Use --force to proceed." >&2
    exit 1
  else
    echo "Warning: proceeding with existing tag $tag due to --force (local: $local_exists, remote: $remote_exists)."
  fi
fi

# Create annotated tag if it does not exist yet
if [[ "$local_exists" != true ]]; then
  echo "Creating annotated tag $tag"
  git tag -a "$tag" -m "$notes"
fi

# Ensure tag is pushed
if [[ "$remote_exists" != true ]]; then
  echo "Pushing tag $tag to $remote"
  git push "$remote" "$tag"
fi

# Create the GitHub Release if it doesn't already exist
if gh release view "$tag" >/dev/null 2>&1; then
  echo "Release $tag already exists"
else
  echo "Creating GitHub Release $tag"
  gh release create "$tag" --title "$tag" --notes "$notes"
  echo "Release $tag created"
fi

echo "Done."


