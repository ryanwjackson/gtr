#!/usr/bin/env bash
set -euo pipefail

# Function to get the latest version tag from git
get_current_version() {
  # Get the latest tag that looks like a version (vX.Y.Z)
  local latest_tag
  latest_tag=$(git tag -l 'v*.*.*' --sort=-version:refname | head -n1)
  if [[ -z "$latest_tag" ]]; then
    echo "v0.0.0"  # Default if no version tags exist
  else
    echo "$latest_tag"
  fi
}

# Function to bump version based on type
bump_version() {
  local current_version="$1"
  local bump_type="$2"

  # Remove 'v' prefix for processing
  local version_numbers="${current_version#v}"

  # Split into major.minor.patch
  local major minor patch
  IFS='.' read -r major minor patch <<< "$version_numbers"

  case "$bump_type" in
    major)
      major=$((major + 1))
      minor=0
      patch=0
      ;;
    minor)
      minor=$((minor + 1))
      patch=0
      ;;
    patch)
      patch=$((patch + 1))
      ;;
    *)
      echo "Error: Invalid bump type: $bump_type" >&2
      exit 1
      ;;
  esac

  echo "v$major.$minor.$patch"
}

usage() {
  cat <<'USAGE'
Usage: bin/release [options] <version>

Create a GitHub Release for the given version.

Arguments:
  version              Semver like 1.2.3 or v1.2.3, or bump keyword (major, minor, patch).
                       The leading "v" will be added if missing for explicit versions.
                       Bump keywords will increment the latest git tag version.

Options:
  -m, --message <msg>  Release notes/title message. Defaults to the normalized version string.
  -f, --force          Allow using an existing tag (locally or on remote).
  -h, --help           Show this help.

Environment:
  Requires GitHub CLI (gh) authenticated to your repo (gh auth status).

Behavior:
  - Normalizes the tag to start with 'v' (e.g., 1.2.3 -> v1.2.3).
  - Creates an annotated git tag locally if missing, pushes it to the remote.
  - Creates a GitHub Release for the tag if it does not already exist.
  - Fails if the tag already exists locally or remotely unless --force is provided.
  - When releasing from a worktree (not main branch), automatically creates a PR with auto-merge enabled.

Examples:
  # Simple release with explicit version
  bin/release 0.1.2

  # Explicit tag format is also accepted
  bin/release v0.1.2

  # Bump patch version from current (e.g., v1.2.3 -> v1.2.4)
  bin/release patch

  # Bump minor version from current (e.g., v1.2.3 -> v1.3.0)
  bin/release minor

  # Bump major version from current (e.g., v1.2.3 -> v2.0.0)
  bin/release major

  # Provide custom release notes/title
  bin/release patch -m "Bugfixes and improvements"

  # Release from worktree (creates PR with auto-merge)
  bin/release 1.2.3  # When run from a worktree branch, creates PR to main
USAGE
}

message=""
version=""
force=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -m|--message)
      shift
      [[ $# -gt 0 ]] || { echo "Error: --message requires an argument" >&2; exit 1; }
      message="$1"
      shift
      ;;
    -h|--help)
      usage; exit 0
      ;;
    -f|--force)
      force=true
      shift
      ;;
    --)
      shift; break
      ;;
    -*)
      echo "Unknown option: $1" >&2
      usage; exit 1
      ;;
    *)
      if [[ -z "$version" ]]; then
        version="$1"
        shift
      else
        echo "Unexpected extra argument: $1" >&2
        usage; exit 1
      fi
      ;;
  esac
done

if [[ -z "$version" ]]; then
  echo "Error: version is required" >&2
  usage
  exit 1
fi

# Handle semantic version keywords or explicit versions
if [[ "$version" =~ ^(major|minor|patch)$ ]]; then
  # Get current version and bump it
  current_version=$(get_current_version)
  tag=$(bump_version "$current_version" "$version")
  echo "Bumping $version from $current_version to $tag"
else
  # Normalize explicit version to start with 'v'
  if [[ "$version" != v* ]]; then
    tag="v$version"
  else
    tag="$version"
  fi

  # Basic semver validation (vMAJOR.MINOR.PATCH)
  if ! [[ "$tag" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo "Error: version must be semantic version (e.g., 1.2.3 or v1.2.3) or bump keyword (major, minor, patch)" >&2
    exit 1
  fi
fi

notes="${message:-$tag}"

# Ensure gh is available and authenticated
if ! command -v gh >/dev/null 2>&1; then
  echo "Error: GitHub CLI 'gh' not found. Install from https://cli.github.com/" >&2
  exit 1
fi
if ! gh auth status >/dev/null 2>&1; then
  echo "Error: gh is not authenticated. Run 'gh auth login' or set GH_TOKEN." >&2
  exit 1
fi

# Ensure git is available
if ! command -v git >/dev/null 2>&1; then
  echo "Error: git not found" >&2
  exit 1
fi

# Require a clean working tree (no uncommitted changes)
if [[ -n "$(git status --porcelain)" ]]; then
  echo "Error: working tree has uncommitted changes. Commit or stash before releasing." >&2
  git status --short || true
  exit 1
fi

# Determine default remote
remote="origin"
if ! git remote get-url "$remote" >/dev/null 2>&1; then
  # Fallback to first remote, if any
  if first_remote=$(git remote | head -n1); then
    remote="$first_remote"
  else
    echo "Error: no git remote configured" >&2
    exit 1
  fi
fi

# Detect if we're in a worktree and not on main branch
git_dir=$(git rev-parse --git-dir)
is_worktree=false
main_branch="main"

# Check if we're in a worktree
if [[ "$git_dir" == *"/.git/worktrees/"* ]]; then
  is_worktree=true
fi

# Try to detect main branch (check for main, master, or main branch from remote)
if git show-ref --verify --quiet "refs/heads/main"; then
  main_branch="main"
elif git show-ref --verify --quiet "refs/heads/master"; then
  main_branch="master"
else
  # Try to get default branch from remote
  if command -v git >/dev/null 2>&1; then
    local default_branch
    default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
    if [[ -n "$default_branch" ]]; then
      main_branch="$default_branch"
    fi
  fi
fi

# Ensure the current branch is pushed before creating the release/tag
current_branch="$(git rev-parse --abbrev-ref HEAD)"
if [[ "$current_branch" != "HEAD" ]]; then
  echo "Pushing local commits on branch $current_branch to $remote"
  
  # Check if remote branch exists
  if git ls-remote --heads "$remote" "$current_branch" | grep -q "$current_branch"; then
    echo "Remote branch $current_branch already exists, pushing updates"
    if git rev-parse --verify "@{u}" >/dev/null 2>&1; then
      git push "$remote" "$current_branch"
    else
      echo "Setting upstream to $remote/$current_branch"
      git push -u "$remote" "$current_branch"
    fi
  else
    echo "Creating new remote branch $current_branch"
    if git rev-parse --verify "@{u}" >/dev/null 2>&1; then
      git push "$remote" "$current_branch"
    else
      echo "Setting upstream to $remote/$current_branch"
      git push -u "$remote" "$current_branch"
    fi
  fi
else
  echo "Detached HEAD; skipping branch push"
fi

## Tag existence checks
local_exists=false
remote_exists=false
if git rev-parse "$tag" >/dev/null 2>&1; then
  local_exists=true
fi
if git ls-remote --tags "$remote" "$tag" | grep -q "$tag"; then
  remote_exists=true
fi

if [[ "$local_exists" == true || "$remote_exists" == true ]]; then
  if [[ "$force" != true ]]; then
    echo "Error: tag $tag already exists (local: $local_exists, remote: $remote_exists). Use --force to proceed." >&2
    exit 1
  else
    echo "Warning: proceeding with existing tag $tag due to --force (local: $local_exists, remote: $remote_exists)."
  fi
fi

# Create annotated tag if it does not exist yet
if [[ "$local_exists" != true ]]; then
  echo "Creating annotated tag $tag"
  git tag -a "$tag" -m "$notes"
fi

# Ensure tag is pushed
if [[ "$remote_exists" != true ]]; then
  echo "Pushing tag $tag to $remote"
  git push "$remote" "$tag"
fi

# Create the GitHub Release if it doesn't already exist
if gh release view "$tag" >/dev/null 2>&1; then
  echo "Release $tag already exists"
else
  echo "Creating GitHub Release $tag"
  gh release create "$tag" --title "$tag" --notes "$notes"
  echo "Release $tag created"
fi

# If we're in a worktree and not on the main branch, create a PR with auto-merge
if [[ "$is_worktree" == "true" && "$current_branch" != "HEAD" && "$current_branch" != "$main_branch" ]]; then
  echo "Detected worktree release from branch $current_branch (not $main_branch)"
  
  # Check if a PR already exists for this branch
  existing_pr=$(gh pr list --head "$current_branch" --base "$main_branch" --json number,state --jq '.[0]' 2>/dev/null)
  
  if [[ -n "$existing_pr" && "$existing_pr" != "null" ]]; then
    pr_number=$(echo "$existing_pr" | jq -r '.number')
    pr_state=$(echo "$existing_pr" | jq -r '.state')
    
    if [[ "$pr_state" == "OPEN" ]]; then
      echo "üìã PR #$pr_number already exists for this branch (state: $pr_state)"
      echo "üîó View existing PR: $(gh pr view "$pr_number" --web --json url --jq '.url' 2>/dev/null)"
      
      # Check if auto-merge is already enabled
      auto_merge_status=$(gh pr view "$pr_number" --json autoMergeRequest --jq '.autoMergeRequest.enabledAt' 2>/dev/null)
      if [[ "$auto_merge_status" == "null" || -z "$auto_merge_status" ]]; then
        echo "üîÑ Enabling auto-merge on existing PR #$pr_number"
        if gh pr merge "$pr_number" --auto --squash 2>/dev/null; then
          echo "‚úÖ Auto-merge enabled for existing PR #$pr_number"
        else
          echo "‚ö†Ô∏è  Could not enable auto-merge on existing PR #$pr_number"
        fi
      else
        echo "‚úÖ Auto-merge already enabled on PR #$pr_number"
      fi
    else
      echo "üìã PR #$pr_number exists but is $pr_state (not open)"
      echo "üîó View PR: $(gh pr view "$pr_number" --web --json url --jq '.url' 2>/dev/null)"
    fi
  else
    echo "Creating new PR to merge $current_branch into $main_branch with auto-merge enabled"
    
    # Create PR title and body
    pr_title="Release $tag from worktree"
    pr_body="This PR merges the release $tag from worktree branch \`$current_branch\` into \`$main_branch\`.

**Release Details:**
- Tag: \`$tag\`
- Release Notes: $notes
- Created from worktree branch: \`$current_branch\`

This PR is set to auto-merge once CI passes."
    
    # Create the PR
    if gh pr create --title "$pr_title" --body "$pr_body" --base "$main_branch" --head "$current_branch" 2>/dev/null; then
      echo "‚úÖ PR created successfully"
      
      # Enable auto-merge on the PR
      pr_number=$(gh pr list --head "$current_branch" --base "$main_branch" --json number --jq '.[0].number' 2>/dev/null)
      if [[ -n "$pr_number" && "$pr_number" != "null" ]]; then
        if gh pr merge "$pr_number" --auto --squash 2>/dev/null; then
          echo "‚úÖ Auto-merge enabled for PR #$pr_number"
          echo "üîó View PR: $(gh pr view "$pr_number" --web --json url --jq '.url' 2>/dev/null)"
        else
          echo "‚ö†Ô∏è  PR created but auto-merge could not be enabled. You may need to enable it manually."
          echo "üîó View PR: $(gh pr view "$pr_number" --web --json url --jq '.url' 2>/dev/null)"
        fi
      else
        echo "‚ö†Ô∏è  PR created but could not retrieve PR number for auto-merge setup"
      fi
    else
      echo "‚ùå Failed to create PR. You may need to create it manually."
      echo "üí° Suggested command:"
      echo "   gh pr create --title \"$pr_title\" --body \"$pr_body\" --base \"$main_branch\" --head \"$current_branch\""
    fi
  fi
fi

echo "Done."


