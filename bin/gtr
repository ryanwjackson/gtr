#!/bin/bash

# gtr - Git worktree helper
# ref: https://medium.com/@dtunai/mastering-git-worktrees-with-claude-code-for-parallel-development-workflow-41dc91e645fe
#
# Examples
# --------
#   gtr create feature0          # add ~/Documents/dev/worktrees/repo-name/feature0 (based on current branch)
#   gtr create feat1 feat2       # add two worktrees at once
#   gtr create feature0 --base main  # create worktree based on main branch
#   gtr create feature0 --no-install # create worktree without running pnpm commands
#   gtr rm feature0              # remove the worktree directory
#   gtr cd feature0              # jump into the worktree directory
#   gtr claude feature0          # run `claude` while inside that worktree
#   gtr prune                    # clean up merged worktrees
#   gtr doctor feature0          # check for missing local files in worktree
#   gtr doctor feature0 --fix    # check and fix missing local files
#
# ------------------------------------------------------------

# Source library files in dependency order
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/gtr-core.sh"     # Core utilities and constants
source "$SCRIPT_DIR/../lib/gtr-ui.sh"       # User interaction
source "$SCRIPT_DIR/../lib/gtr-config.sh"   # Configuration management
source "$SCRIPT_DIR/../lib/gtr-files.sh"    # File operations
source "$SCRIPT_DIR/../lib/gtr-hooks.sh"    # Hook execution
source "$SCRIPT_DIR/../lib/gtr-git.sh"      # Git operations
source "$SCRIPT_DIR/../lib/gtr-commands.sh" # Command implementations
source "$SCRIPT_DIR/../lib/gtr-ideas.sh"    # Idea management

# Default version string placeholder; replaced during release packaging
GTR_VERSION="@VERSION@"

# Version output helper for CLI
_gtr_print_version() {
  # If we have a real version (not the placeholder), use it directly
  if [[ -n "$GTR_VERSION" && "$GTR_VERSION" =~ ^v?[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
    echo "$GTR_VERSION"
    return
  fi

  # Otherwise, try to get version from various sources
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local version_info=""

  # Method 1: Check Homebrew formula info first (for installed versions)
  if command -v brew >/dev/null 2>&1; then
    local brew_info
    brew_info=$(brew list --versions gtr 2>/dev/null | head -1)
    if [[ -n "$brew_info" ]]; then
      local brew_version="${brew_info#gtr }"
      echo "$brew_version"
      return
    fi
  fi

  # Method 2: Check if we're in a git repository (development case)
  if [[ -d "$script_dir/../.git" ]] && command -v git >/dev/null 2>&1; then
    local git_describe
    git_describe=$(cd "$script_dir/.." && git describe --tags --always 2>/dev/null)
    if [[ -n "$git_describe" ]]; then
      version_info=" ($git_describe)"
    fi
    echo "dev${version_info}"
    return
  fi

  # Method 3: Try to extract from script path (some package managers include version in path)
  if [[ "$script_dir" =~ /([0-9]+\.[0-9]+(\.[0-9]+)?)/bin$ ]]; then
    local path_version="${BASH_REMATCH[1]}"
    echo "$path_version"
    return
  fi

  # Fallback
  echo "unknown"
}

# Private helper functions (prefixed with _gtr_)
_gtr_get_base_dir() {
  local repo_name="$(_gtr_get_repo_name)"
  echo "${GTR_BASE_DIR:-$HOME/Documents/dev/worktrees/$repo_name}"
}

# Helper function for interactive user input
# Usage: _gtr_ask_user "prompt" "default_value"
# Returns: user input or default value if no interactive input available
_gtr_ask_user() {
  local prompt="$1"
  local default_value="${2:-}"

  printf "%s" "$prompt"

  if [[ -t 0 ]]; then
    # Terminal input available, read user input with timeout to prevent hanging
    if read -r -t 10 reply 2>/dev/null; then
      if [[ -z "$reply" ]]; then
        # Empty input, use default
        echo "$default_value"
      else
        # Use user input
        echo "$reply"
      fi
    else
      # Read timed out or failed, use default
      echo "$default_value"
    fi
  else
    # No interactive input available, but check if there's input to read
    if read -r -t 1 reply 2>/dev/null; then
      # There's input available, use it
      if [[ -z "$reply" ]]; then
        echo "$default_value"
      else
        echo "$reply"
      fi
    else
      # No input available, return default
      echo "$default_value"
    fi
  fi
}

# Helper function for getting repository name
# Usage: _gtr_get_repo_name
# Returns: repository name from git remote or directory name
_gtr_get_repo_name() {
  # Try to get repo name from git remote origin
  local repo_name=$(git remote get-url origin 2>/dev/null | sed 's/.*\///' | sed 's/\.git$//')
  
  # If that fails, use the directory name
  if [[ -z "$repo_name" ]]; then
    repo_name=$(basename "$(git rev-parse --show-toplevel 2>/dev/null)")
  fi
  
  # Fallback to a default if still empty
  if [[ -z "$repo_name" ]]; then
    repo_name="unknown-repo"
  fi
  
  echo "$repo_name"
}

# Helper function for generating worktree branch names
# Usage: _gtr_get_worktree_branch_name "worktree_name"
# Returns: worktrees/$repo_name/$username/$worktree_name
_gtr_get_worktree_branch_name() {
  local worktree_name="$1"
  local username="${_GTR_USERNAME:-$(whoami)}"
  local repo_name="$(_gtr_get_repo_name)"
  echo "worktrees/$repo_name/$username/$worktree_name"
}

_gtr_read_config() {
  local main_worktree="$1"
  local global_config_file="$HOME/.gtr/config"
  local local_config_file="$main_worktree/.gtr/config"
  local config_file=""
  local patterns=()

  # Check for global config first, then local config overrides it
  if [[ -f "$global_config_file" ]]; then
    config_file="$global_config_file"
  fi
  if [[ -f "$local_config_file" ]]; then
    config_file="$local_config_file"
  fi

  if [[ -n "$config_file" && -f "$config_file" ]]; then
    local in_files_section=false
    local line_count=0
    local max_lines=1000  # Prevent infinite loops
    local error_count=0
    local max_errors=10   # Stop after too many errors
    
    while IFS= read -r line && (( line_count++ < max_lines )) && (( error_count < max_errors )); do
      # Check for section headers - use string matching instead of regex to avoid escaping issues
      if [[ "$line" == "[files_to_copy]" ]]; then
        in_files_section=true
        continue
      elif [[ "$line" =~ ^\[ ]]; then
        in_files_section=false
        continue
      fi
      
      # Only process lines in the [files_to_copy] section
      if [[ "$in_files_section" == "true" ]]; then
        # Skip comments and empty lines - use safer pattern matching
        if [[ -n "$line" && ! "$line" =~ ^[[:space:]]*# ]]; then
          # Basic validation - skip lines that look like section headers or malformed content
          if [[ ! "$line" =~ ^\[ && ! "$line" =~ ^[[:space:]]*\[ ]]; then
            patterns+=("$line")
          else
            ((error_count++))
            echo "Warning: Skipping malformed line in config: $line" >&2
          fi
        fi
      fi
    done < "$config_file"
    
    # If we hit the line limit, something might be wrong
    if (( line_count >= max_lines )); then
      echo "Warning: Config file too large or malformed" >&2
    fi
    
    # If we hit too many errors, the config file might be corrupted
    if (( error_count >= max_errors )); then
      echo "Error: Too many malformed lines in config file. Consider recreating it." >&2
      echo "Run 'gtr init' to recreate the configuration file." >&2
      return 1
    fi
  fi
  
  # Fallback to default patterns if none found
  if [[ ${#patterns[@]} -eq 0 ]]; then
    patterns=(".env*local*" ".claude/" ".anthropic/")
  fi
  
  echo "${patterns[@]}"
}

_gtr_read_config_setting() {
  local main_worktree="$1"
  local section="$2"
  local key="$3"
  local default="$4"
  local global_config_file="$HOME/.gtr/config"
  local local_config_file="$main_worktree/.gtr/config"
  local config_file=""

  # Check for global config first, then local config overrides it
  if [[ -f "$global_config_file" ]]; then
    config_file="$global_config_file"
  fi
  if [[ -f "$local_config_file" ]]; then
    config_file="$local_config_file"
  fi

  if [[ -z "$config_file" || ! -f "$config_file" ]]; then
    echo "$default"
    return
  fi
  
  # Validate inputs to prevent issues
  if [[ -z "$section" || -z "$key" ]]; then
    echo "$default"
    return
  fi
  
  local in_section=false
  local line_count=0
  local max_lines=1000  # Prevent infinite loops
  local error_count=0
  local max_errors=5     # Stop after too many errors
  
  while IFS= read -r line && (( line_count++ < max_lines )) && (( error_count < max_errors )); do
    # Check for section headers - use string matching instead of regex to avoid escaping issues
    if [[ "$line" == "[$section]" ]]; then
      in_section=true
      continue
    elif [[ "$line" =~ ^\[ ]]; then
      in_section=false
      continue
    fi
    
    # Only process lines in the target section
    if [[ "$in_section" == "true" ]]; then
      # Skip comments and empty lines - use safer pattern matching
      if [[ -n "$line" && ! "$line" =~ ^[[:space:]]*# ]]; then
        # Use string matching with prefix check instead of regex
        if [[ "$line" == "$key="* ]]; then
          echo "${line#*=}"
          return
        fi
      fi
    fi
  done < "$config_file" 2>/dev/null || {
    echo "Warning: Error reading config file, using default value" >&2
    echo "$default"
    return
  }
  
  # If we hit the line limit, something might be wrong
  if (( line_count >= max_lines )); then
    echo "Warning: Config file too large or malformed, using default value" >&2
  fi
  
  # If we hit too many errors, the config file might be corrupted
  if (( error_count >= max_errors )); then
    echo "Warning: Config file appears corrupted, using default value" >&2
  fi
  
  echo "$default"
}

_gtr_handle_malformed_config() {
  local main_worktree="$1"
  local config_file="$main_worktree/.gtr/config"
  
  echo "‚ùå The existing .gtr/config file appears to be malformed or corrupted."
  echo ""
  echo "This can happen when:"
  echo "  ‚Ä¢ The config file was manually edited with invalid syntax"
  echo "  ‚Ä¢ The config file was created with an older version of gtr"
  echo "  ‚Ä¢ The file was corrupted during editing"
  echo ""
  echo "Options:"
  echo "  1. Overwrite with a fresh default configuration"
  echo "  2. Show diff between current and default config"
  echo "  3. Try to merge/repair the existing config"
  echo "  4. Exit and fix manually"
  echo ""
  
  while true; do
    local choice
    choice=$(_gtr_ask_user "Choose an option (1-4): " "4")
    case $choice in
      1)
        echo "üîÑ Creating fresh configuration..."
        _gtr_init_config "$main_worktree" "$(dirname "$config_file")" "$config_file"
        return 0
        ;;
      2)
        echo "üìã Showing diff between current and default config:"
        echo "--- Current config ---"
        cat "$config_file" 2>/dev/null || echo "(unable to read current config)"
        echo ""
        echo "--- Default config ---"
        _gtr_generate_default_config
        return 1
        ;;
      3)
        echo "üîß Attempting to repair existing config..."
        _gtr_repair_config "$config_file"
        return $?
        ;;
      4)
        echo "‚ÑπÔ∏è  Exiting. You can manually edit $config_file and try again."
        return 1
        ;;
      *)
        echo "Invalid option. Please choose 1-4."
        ;;
    esac
  done
}

_gtr_generate_default_config() {
  cat << 'EOF'
# gtr configuration file
# This file defines gtr behavior and which files should be copied to worktrees

[files_to_copy]
# File patterns to copy (glob patterns, one per line)
# Default patterns for local environment files
.env*local*
.env.*local*

# Claude settings directories
.claude/
.anthropic/

# Add more patterns as needed
# Example:
# config/local.json
# secrets/*.local

[settings]
# Default editor to open worktrees
editor=cursor


# Whether to run pnpm commands by default
run_pnpm=true

# Whether to open editor after creating worktree
auto_open=true

# Base directory for worktrees (relative to main repo or absolute path)
# worktree_base=../worktrees

[doctor]
# Whether to show detailed diff information
show_detailed_diffs=false

# Whether to auto-fix missing files without prompts
auto_fix=false
EOF
}

_gtr_repair_config() {
  local config_file="$1"
  local backup_file="${config_file}.backup.$(date +%s)"
  
  # Create backup
  cp "$config_file" "$backup_file" 2>/dev/null || {
    echo "‚ùå Unable to create backup of config file"
    return 1
  }
  
  echo "üìã Created backup: $backup_file"
  
  # Try to extract valid patterns from the existing config
  local patterns=()
  local in_files_section=false
  
  while IFS= read -r line; do
    if [[ "$line" == "[files_to_copy]" ]]; then
      in_files_section=true
      continue
    elif [[ "$line" == "["* ]]; then
      in_files_section=false
      continue
    fi
    
    if [[ "$in_files_section" == "true" ]]; then
      # Skip empty lines, comments, and section headers
      if [[ -n "$line" && "$line" != "#"* && "$line" != "["* ]]; then
        patterns+=("$line")
      fi
    fi
  done < "$config_file"
  
  # Generate new config with extracted patterns
  {
    echo "# gtr configuration file (repaired)"
    echo "# This file defines gtr behavior and which files should be copied to worktrees"
    echo ""
    echo "[files_to_copy]"
    echo "# File patterns to copy (glob patterns, one per line)"
    if [[ ${#patterns[@]} -gt 0 ]]; then
      echo "# Extracted from previous config:"
      for pattern in "${patterns[@]}"; do
        echo "$pattern"
      done
    else
      echo "# Default patterns for local environment files"
      echo ".env*local*"
      echo ".env.*local*"
      echo ""
      echo "# Claude settings directories"
      echo ".claude/"
      echo ".anthropic/"
    fi
    echo ""
    echo "[settings]"
    echo "editor=cursor"
    echo "run_pnpm=true"
    echo "auto_open=true"
    echo ""
    echo "[doctor]"
    echo "show_detailed_diffs=false"
    echo "auto_fix=false"
  } > "$config_file"
  
  echo "‚úÖ Config file repaired successfully"
  echo "üìã Extracted ${#patterns[@]} patterns from the original config"
  return 0
}

_gtr_copy_local_files() {
  local source_dir="$1"
  local target_dir="$2"
  local force="${3:-false}"
  local main_worktree="${4:-$source_dir}"
  local copied_files=()
  
  # Read configuration patterns
  local patterns=($(_gtr_read_config "$main_worktree"))
  
  if [[ -d "$source_dir" ]]; then
    for pattern in "${patterns[@]}"; do
      if [[ "$pattern" == */ ]]; then
        # Directory pattern
        local dir_name="${pattern%/}"
        if [[ -d "$source_dir/$dir_name" ]]; then
          if cp -r "$source_dir/$dir_name" "$target_dir/" 2>/dev/null; then
            copied_files+=("$dir_name/")
          fi
        fi
      else
        # File pattern - use find to search recursively
        while IFS= read -r -d '' file; do
          if [[ -f "$file" ]]; then
            local relative_path="${file#$source_dir/}"
            local target_path="$target_dir/$relative_path"
            local target_dir_path=$(dirname "$target_path")
            
            # Create target directory if it doesn't exist
            mkdir -p "$target_dir_path" 2>/dev/null
            
            # Check if target file exists and is different
            if [[ -f "$target_path" ]] && _gtr_files_different "$file" "$target_path"; then
              if _gtr_interactive_overwrite "$file" "$target_path" "$target_path" "$force"; then
                copied_files+=("$relative_path")
              fi
            else
              # File doesn't exist or is the same, safe to copy
              if cp "$file" "$target_path" 2>/dev/null; then
                copied_files+=("$relative_path")
              fi
            fi
          fi
        done < <(find "$source_dir" -name "$pattern" -type f -print0 2>/dev/null)
      fi
    done
  fi
  
  # Report what was copied
  if [[ ${#copied_files[@]} -gt 0 ]]; then
    echo "üìã Copied local files: ${copied_files[*]}"
  else
    echo "‚ÑπÔ∏è  No local files found to copy"
  fi
}

_gtr_run_pnpm_commands() {
  local worktree_dir="$1"
  local no_install="$2"
  
  if [[ "$no_install" == "true" ]]; then
    echo "‚è≠Ô∏è  Skipping pnpm commands (--no-install specified)"
    return 0
  fi
  
  if [[ -f "$worktree_dir/package.json" ]]; then
    echo "üì¶ Running pnpm commands in worktree..."
    
    # Run pnpm approve-builds
    if command -v pnpm >/dev/null 2>&1; then
      echo "  Running pnpm approve-builds..."
      (cd "$worktree_dir" && pnpm approve-builds) || echo "  ‚ö†Ô∏è  pnpm approve-builds failed"
      
      echo "  Running pnpm install..."
      (cd "$worktree_dir" && pnpm install) || echo "  ‚ö†Ô∏è  pnpm install failed"
    else
      echo "  ‚ö†Ô∏è  pnpm not found, skipping pnpm commands"
    fi
  else
    echo "‚ÑπÔ∏è  No package.json found, skipping pnpm commands"
  fi
}

_gtr_files_different() {
  local file1="$1"
  local file2="$2"
  
  if [[ ! -f "$file1" || ! -f "$file2" ]]; then
    return 1
  fi
  
  # Use diff to check if files are different
  if diff -q "$file1" "$file2" >/dev/null 2>&1; then
    return 1  # Files are the same
  else
    return 0  # Files are different
  fi
}

_gtr_show_diff() {
  local file1="$1"
  local file2="$2"
  
  echo "üìã Showing diff between main repo and worktree:"
  echo "  Main repo: $file1"
  echo "  Worktree:  $file2"
  echo ""
  
  if command -v diff >/dev/null 2>&1; then
    diff -u "$file1" "$file2" || true
  else
    echo "‚ö†Ô∏è  diff command not available"
  fi
  echo ""
}

_gtr_merge_files() {
  local main_file="$1"
  local worktree_file="$2"
  local target_file="$3"
  
  echo "üîÄ Merging files..."
  
  if command -v diff3 >/dev/null 2>&1; then
    # Use diff3 for three-way merge if available
    if diff3 -m "$main_file" "$worktree_file" "$worktree_file" > "$target_file" 2>/dev/null; then
      echo "‚úÖ Successfully merged using diff3"
      return 0
    fi
  fi
  
  # Fallback: simple merge by appending worktree changes
  echo "üìù Using simple merge strategy..."
  cp "$main_file" "$target_file"
  echo "" >> "$target_file"
  echo "# Worktree-specific changes:" >> "$target_file"
  if command -v diff >/dev/null 2>&1; then
    diff -u "$main_file" "$worktree_file" >> "$target_file" 2>/dev/null || true
  fi
  
  echo "‚úÖ Files merged (manual review recommended)"
  return 0
}

_gtr_interactive_overwrite() {
  local main_file="$1"
  local worktree_file="$2"
  local target_file="$3"
  local force="$4"
  
  if [[ "$force" == "true" ]]; then
    echo "üîÑ Force overwriting: $(basename "$worktree_file")"
    cp "$main_file" "$target_file"
    return 0
  fi
  
  echo ""
  echo "‚ö†Ô∏è  File already exists and is different: $(basename "$worktree_file")"
  echo "   Main repo: $main_file"
  echo "   Worktree:  $worktree_file"
  echo ""
  echo "What would you like to do?"
  echo "  [y]es  - Overwrite with main repo version"
  echo "  [n]o   - Skip this file"
  echo "  [d]iff - Show diff and ask again"
  echo "  [m]erge - Merge both files"
  echo ""
  
  while true; do
    local choice
    choice=$(_gtr_ask_user "Choose [y/n/d/m]: " "n")
    case "$choice" in
      [yY]|[yY][eE][sS])
        echo "üîÑ Overwriting with main repo version..."
        cp "$main_file" "$target_file"
        return 0
        ;;
      [nN]|[nN][oO])
        echo "‚è≠Ô∏è  Skipping file..."
        return 1
        ;;
      [dD]|[dD][iI][fF][fF])
        _gtr_show_diff "$main_file" "$worktree_file"
        # Ask again after showing diff
        ;;
      [mM]|[mM][eE][rR][gG][eE])
        _gtr_merge_files "$main_file" "$worktree_file" "$target_file"
        return 0
        ;;
      *)
        echo "Invalid choice. Please choose y, n, d, or m."
        ;;
    esac
  done
}

_gtr_get_main_worktree() {
  # Get the main worktree (the one that's not a worktree)
  local current_worktree=$(git rev-parse --show-toplevel)
  local git_dir=$(git rev-parse --git-dir)
  
  # If we're in a worktree, the git-dir will be in .git/worktrees/
  # The main worktree is the parent of the .git directory
  if [[ "$git_dir" == *"/.git/worktrees/"* ]]; then
    # We're in a worktree, get the main repository
    local main_git_dir=$(dirname "$(dirname "$git_dir")")
    # The main worktree is the parent of the .git directory
    echo "$(dirname "$main_git_dir")"
  else
    # We're in the main repository
    echo "$current_worktree"
  fi
}

_gtr_is_initialized() {
  local main_worktree="$(_gtr_get_main_worktree)"
  local global_config_file="$HOME/.gtr/config"
  local local_config_file="$main_worktree/.gtr/config"

  # Check if either global or local config file exists
  if [[ -f "$local_config_file" || -f "$global_config_file" ]]; then
    return 0  # Initialized
  else
    return 1  # Not initialized
  fi
}

_gtr_parse_global_flags() {
  local main_worktree="$(_gtr_get_main_worktree)"
  local editor="cursor"
  local no_open=false
  local no_install=false
  local username=$(whoami)
  local base_branch=""
  local untracked=""
  local uncommitted=""
  local git_root=""
  local args=()
  local extra_args=()
  local parsing_extra=false


  # Read default values from config
  local config_editor="$(_gtr_read_config_setting "$main_worktree" "settings" "editor" "cursor")"
  local config_run_pnpm="$(_gtr_read_config_setting "$main_worktree" "settings" "run_pnpm" "true")"
  local config_auto_open="$(_gtr_read_config_setting "$main_worktree" "settings" "auto_open" "true")"
  local config_worktree_base="$(_gtr_read_config_setting "$main_worktree" "settings" "worktree_base" "")"
  local config_untracked="$(_gtr_read_config_setting "$main_worktree" "settings" "untracked" "true")"
  
  # Set defaults from config
  editor="$config_editor"

  # Set worktree base if configured
  if [[ -n "$config_worktree_base" ]]; then
    if [[ "$config_worktree_base" == /* ]]; then
      # Absolute path
      export GTR_BASE_DIR="$config_worktree_base"
    else
      # Relative path from main worktree
      export GTR_BASE_DIR="$main_worktree/$config_worktree_base"
    fi
  fi

  while [[ $# -gt 0 ]]; do
    if [[ "$parsing_extra" == "true" ]]; then
      # Everything after -- goes to extra_args
      extra_args+=("$1")
      shift
      continue
    fi

    case "$1" in
      --)
        parsing_extra=true
        shift
        ;;
      --prefix)
        if [[ -n "$2" ]]; then
          prefix="$2"
          shift 2
        else
          echo "Error: --prefix requires a value"
          return 1
        fi
        ;;
      --prefix=*)
        prefix="${1#*=}"
        shift
        ;;
      --editor)
        if [[ -n "$2" ]]; then
          editor="$2"
          shift 2
        else
          echo "Error: --editor requires a value"
          return 1
        fi
        ;;
      --editor=*)
        editor="${1#*=}"
        shift
        ;;
      --username)
        if [[ -n "$2" ]]; then
          username="$2"
          shift 2
        else
          echo "Error: --username requires a value"
          return 1
        fi
        ;;
      --username=*)
        username="${1#*=}"
        shift
        ;;
      --no-open)
        no_open=true
        shift
        ;;
      --no-install)
        no_install=true
        shift
        ;;
      --base)
        if [[ -n "$2" ]]; then
          base_branch="$2"
          shift 2
        else
          echo "Error: --base requires a value"
          return 1
        fi
        ;;
      --base=*)
        base_branch="${1#*=}"
        shift
        ;;
      --untracked)
        if [[ -n "$2" ]]; then
          untracked="$2"
          shift 2
        else
          echo "Error: --untracked requires a value (true or false)"
          return 1
        fi
        ;;
      --untracked=*)
        untracked="${1#*=}"
        shift
        ;;
      --uncommitted)
        if [[ -n "$2" ]]; then
          uncommitted="$2"
          shift 2
        else
          echo "Error: --uncommitted requires a value (true or false)"
          return 1
        fi
        ;;
      --uncommitted=*)
        uncommitted="${1#*=}"
        shift
        ;;
      --git-root)
        if [[ -n "$2" ]]; then
          git_root="$2"
          shift 2
        else
          echo "Error: --git-root requires a directory path"
          return 1
        fi
        ;;
      --git-root=*)
        git_root="${1#*=}"
        shift
        ;;
      --force|--dry-run|--mine|--todo|--status=*|--filter=*)
        # These are command-specific flags, pass them through
        args+=("$1")
        shift
        ;;
      --*)
        echo "Error: Unknown option '$1'"
        echo "Valid global options: --prefix, --username, --editor, --no-open, --no-install, --base, --untracked, --uncommitted, --git-root"
        echo "Command-specific options: --force, --dry-run (for rm command), --mine, --todo, --status, --filter (for idea command)"
        return 1
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done

  # Apply config-based defaults if not overridden by flags
  if [[ "$no_open" == "false" && "$config_auto_open" == "false" ]]; then
    no_open=true
  fi

  if [[ "$no_install" == "false" && "$config_run_pnpm" == "false" ]]; then
    no_install=true
  fi
  
  # Set untracked default from config if not specified
  if [[ -z "$untracked" ]]; then
    untracked="$config_untracked"
  fi
  

  # Export variables for use in other functions
  export _GTR_EDITOR="$editor"
  export _GTR_NO_OPEN="$no_open"
  export _GTR_NO_INSTALL="$no_install"
  export _GTR_USERNAME="$username"
  export _GTR_BASE_BRANCH="$base_branch"
  export _GTR_UNTRACKED="$untracked"
  export _GTR_UNCOMMITTED="$uncommitted"
  export _GTR_GIT_ROOT="$git_root"
  
  # Set _GTR_ARGS and _GTR_EXTRA_ARGS in the global scope
  _GTR_ARGS=("${args[@]}")
  _GTR_EXTRA_ARGS=("${extra_args[@]}")
  export _GTR_ARGS
  export _GTR_EXTRA_ARGS
}

_gtr_find_or_create_worktree() {
  local name="$1"
  local should_open="${2:-false}"
  local base="$(_gtr_get_base_dir)"
  local dir="$base/$name"

  # If worktree already exists, return success
  if [[ -d "$dir" ]]; then
    echo "$dir"
    return 0
  fi

  # Check if configuration exists (either global or local)
  if ! _gtr_is_initialized; then
    echo "‚ùå No gtr configuration found" >&2
    echo "   Run 'gtr init' to create a global configuration (~/.gtr/config)" >&2
    echo "   or create a local configuration in this repository (.gtr/config)" >&2
    return 1
  fi

  # Prompt to create worktree
  local reply
  reply=$(_gtr_ask_user "Worktree '$name' doesn't exist. Create it now? [y/N] " "N")
  case "$reply" in
    [yY]|[yY][eE][sS])
      local branch_name="$(_gtr_get_worktree_branch_name "$name")"

      # Check if branch already exists
      if git show-ref --verify --quiet "refs/heads/$branch_name"; then
        echo "Branch '$branch_name' already exists. Cannot create worktree." >&2
        return 1
      fi

      local base_branch="${_GTR_BASE_BRANCH:-$(git rev-parse --abbrev-ref HEAD)}"
      echo "Creating worktree '$name' based on $base_branch‚Ä¶"

      if git worktree add "$dir" -b "$branch_name" "$base_branch"; then
        echo "‚úÖ Created worktree '$name'"

        # Copy local files from main worktree to new worktree (only if we have files to copy)
        local main_worktree="$(_gtr_get_main_worktree)"
        local patterns=($(_gtr_read_config "$main_worktree"))
        if [[ ${#patterns[@]} -gt 0 ]]; then
          _gtr_copy_local_files "$main_worktree" "$dir" "true" "$main_worktree"
        fi

        # Run pnpm commands if not disabled
        _gtr_run_pnpm_commands "$dir" "${_GTR_NO_INSTALL:-false}"

        echo "$dir"
        return 0
      else
        echo "git worktree add failed" >&2
        return 1
      fi
      ;;
    *)
      echo "Aborted." >&2
      return 1
      ;;
  esac
}

_gtr_create_worktree() {
  local name="$1"
  local base_branch="${_GTR_BASE_BRANCH:-$(git rev-parse --abbrev-ref HEAD)}"
  local base="$(_gtr_get_base_dir)"
  local branch_name="$(_gtr_get_worktree_branch_name "$name")"
  local main_worktree="$(_gtr_get_main_worktree)"
  local current_branch="$(git rev-parse --abbrev-ref HEAD)"
  local untracked="${_GTR_UNTRACKED:-true}"
  
  # Validate that --untracked only works when --base is current branch
  if [[ "$untracked" == "true" && "$base_branch" != "$current_branch" ]]; then
    echo "‚ùå Error: --untracked=true can only be used when --base is the current branch"
    echo "   Current branch: $current_branch"
    echo "   Base branch: $base_branch"
    echo "   Use --untracked=false to create worktree from a different base branch"
    return 1
  fi
  
  # Check if branch already exists
  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    echo "Branch '$branch_name' already exists. Skipping '$name'."
    return 1
  fi
  
  # Handle uncommitted changes if requested
  local uncommitted_files=()
  local stash_created=false
  local uncommitted="${_GTR_UNCOMMITTED:-true}"

  # Check for uncommitted changes and handle them appropriately
  local uncommitted_status=$(git status --porcelain)
  if [[ -n "$uncommitted_status" ]]; then
    if [[ "$uncommitted" == "true" ]]; then
      # Use stashing for --uncommitted=true
      echo "üìÅ Including uncommitted changes in worktree..."

      # Show what files will be stashed
      while IFS= read -r line; do
        # Skip empty lines
        if [[ -z "$line" ]]; then
          continue
        fi

        local status_code="${line:0:2}"
        local file_path="${line:3}"

        # Handle renamed files (R  old -> new)
        if [[ "$status_code" =~ ^R ]]; then
          file_path=$(echo "$file_path" | sed 's/.*-> //')
        fi

        # Skip if no file path
        if [[ -z "$file_path" ]]; then
          continue
        fi

        # Determine the type of change
        local change_type=""
        case "$status_code" in
          "??") change_type="new file" ;;
          " M") change_type="modified" ;;
          "M ") change_type="staged" ;;
          "MM") change_type="modified and staged" ;;
          "A ") change_type="added" ;;
          "AM") change_type="added and modified" ;;
          "D ") change_type="deleted" ;;
          " D") change_type="deleted (staged)" ;;
          "R ") change_type="renamed" ;;
          "C ") change_type="copied" ;;
          *) change_type="changed" ;;
        esac

        echo "  üìÑ $change_type: $file_path"
      done <<< "$uncommitted_status"

      # For stashing mode, collect files but don't stash yet - we'll copy to worktree first, then stash
      while IFS= read -r line; do
        # Skip empty lines
        if [[ -z "$line" ]]; then
          continue
        fi

        local status_code="${line:0:2}"
        local file_path="${line:3}"

        # Handle renamed files (R  old -> new)
        if [[ "$status_code" =~ ^R ]]; then
          file_path=$(echo "$file_path" | sed 's/.*-> //')
        fi

        # Skip if no file path
        if [[ -z "$file_path" ]]; then
          continue
        fi

        uncommitted_files+=("$file_path")
      done <<< "$uncommitted_status"
    elif [[ "$untracked" == "true" ]]; then
      # Use file copying for --untracked=true (legacy behavior)
      echo "üìÅ Including uncommitted changes in worktree..."

      # Collect files to copy and log each file that will be moved
      while IFS= read -r line; do
        # Skip empty lines
        if [[ -z "$line" ]]; then
          continue
        fi

        local status_code="${line:0:2}"
        local file_path="${line:3}"

        # Handle renamed files (R  old -> new)
        if [[ "$status_code" =~ ^R ]]; then
          file_path=$(echo "$file_path" | sed 's/.*-> //')
        fi

        # Skip if no file path
        if [[ -z "$file_path" ]]; then
          continue
        fi

        # Determine the type of change
        local change_type=""
        case "$status_code" in
          "??") change_type="new file" ;;
          " M") change_type="modified" ;;
          "M ") change_type="staged" ;;
          "MM") change_type="modified and staged" ;;
          "A ") change_type="added" ;;
          "AM") change_type="added and modified" ;;
          "D ") change_type="deleted" ;;
          " D") change_type="deleted (staged)" ;;
          "R ") change_type="renamed" ;;
          "C ") change_type="copied" ;;
          *) change_type="changed" ;;
        esac

        echo "  üìÑ $change_type: $file_path"
        uncommitted_files+=("$file_path")
      done <<< "$uncommitted_status"
    fi
  fi
  
  # Create worktree and branch from the specified base
  if git worktree add "$base/$name" -b "$branch_name" "$base_branch"; then
    echo "‚úÖ Created worktree '$name' based on $base_branch"

    # Copy uncommitted files to the worktree if requested
    if [[ ${#uncommitted_files[@]} -gt 0 ]]; then
      echo "üìã Copying uncommitted changes to worktree..."
      
      for file_path in "${uncommitted_files[@]}"; do
        local source_file="$main_worktree/$file_path"
        local target_file="$base/$name/$file_path"
        local target_dir=$(dirname "$target_file")
        
        # Create target directory if it doesn't exist
        mkdir -p "$target_dir" 2>/dev/null
        
        # Copy the file
        if [[ -f "$source_file" ]]; then
          cp "$source_file" "$target_file" 2>/dev/null
          echo "  üìÑ Copied: $file_path"
        elif [[ -d "$source_file" ]]; then
          cp -r "$source_file" "$target_file" 2>/dev/null
          echo "  üìÅ Copied directory: $file_path"
        fi
      done
      
      # If we're in stashing mode, now stash the original changes after copying to worktree
      if [[ "$uncommitted" == "true" ]]; then
        echo "  ‚úÖ Changes copied to worktree"

        # Now create the stash in the original location
        local stash_message="Stashed for worktree: $name, branch: $branch_name"
        if git stash push -u -m "$stash_message" >/dev/null 2>&1; then
          echo "üì¶ Stashed original changes with message: '$stash_message'"
          echo "‚ÑπÔ∏è  Use 'git stash pop' to restore changes to original location if needed"
          stash_created=true
        else
          echo "‚ö†Ô∏è  Warning: Failed to stash original changes (changes were copied to worktree)"
        fi
      else
        echo "  ‚ÑπÔ∏è  Files copied to worktree. Git states (staged/modified) will need to be recreated manually."
      fi
    fi

    # Copy local files from main worktree to new worktree (only if we have files to copy)
    local patterns=($(_gtr_read_config "$main_worktree"))
    if [[ ${#patterns[@]} -gt 0 ]]; then
      _gtr_copy_local_files "$main_worktree" "$base/$name" "true" "$main_worktree"
    fi

    # Run pnpm commands if not disabled
    _gtr_run_pnpm_commands "$base/$name" "$_GTR_NO_INSTALL"
    
    if [[ "$_GTR_NO_OPEN" == "false" ]]; then
      echo "Opening '$base/$name' with $_GTR_EDITOR"
      $_GTR_EDITOR "$base/$name"
    else
      echo "Worktree ready at '$base/$name'"
    fi
    return 0
  else
    echo "Failed to create worktree '$name'"
    return 1
  fi
}

# _gtr_remove_worktree() {
#   local name="$1"
#   local force="$2"
#   local dry_run="$3"
#   local base="$(_gtr_get_base_dir)"
#   local branch_name="$(_gtr_get_worktree_branch_name "$name")"
#   local worktree_path=""
#   local worktree_branch=""
#   
#   # First, try to find the worktree by directory name
#   if [[ -d "$base/$name" ]]; then
#     worktree_path="$base/$name"
#     # Get the actual branch the worktree is on
#     worktree_branch=$(git worktree list --porcelain | grep -A1 "worktree $worktree_path" | grep "branch refs/heads/" | sed 's/.*branch refs\/heads\///')
#   else
#     # Try to find worktree by branch name if directory not found
#     worktree_branch="$name"
#     worktree_path=$(git worktree list --porcelain | awk -v branch="$worktree_branch" '
#       /^worktree / { 
#         worktree_path = $2
#       }
#       /^branch refs\/heads\// { 
#         current_branch = substr($0, 19)
#         if (current_branch == branch) {
#           print worktree_path
#           exit
#         }
#       }
#     ')
#     
#     if [[ -z "$worktree_path" ]]; then
#       echo "‚ùå Worktree not found: $name"
#       echo "üí° Available worktrees:"
#       git worktree list
#       return 1
#     fi
#   fi
#   
#   # Try alternative method if the first one didn't work
#   if [[ -z "$worktree_branch" ]]; then
#     worktree_branch=$(git worktree list --porcelain | awk -v worktree="$worktree_path" '
#       /^worktree/ { 
#         if ($0 ~ worktree) { 
#           found=1; next 
#         } else { 
#           found=0; next 
#         }
#       }
#       found && /^branch refs\/heads\// { 
#         gsub(/^branch refs\/heads\//, ""); 
#         print; 
#         exit 
#       }
#     ')
#   fi
#   
#   # Determine which branch to check for deletion
#   local branch_to_check=""
#   local is_fallback=false
#   if git show-ref --verify --quiet "refs/heads/$branch_name"; then
#     branch_to_check="$branch_name"
#   else
#     if [[ -n "$worktree_branch" ]] && git show-ref --verify --quiet "refs/heads/$worktree_branch"; then
#       branch_to_check="$worktree_branch"
#       is_fallback=true
#       echo "Expected branch '$branch_name' not found, but worktree was on branch '$worktree_branch'"
#     fi
#   fi
#   
#   if [[ "$dry_run" == "true" ]]; then
#     echo "üîç [DRY RUN] Would remove worktree: $worktree_path"
#     if [[ -n "$branch_to_check" ]]; then
#       # Safeguard: Never delete main/master branches
#       if [[ "$branch_to_check" == "main" || "$branch_to_check" == "master" ]]; then
#         echo "üîç [DRY RUN] Would skip deletion of main branch '$branch_to_check'"
#       else
#         # Check if branch has uncommitted changes
#         if ! git diff --quiet "HEAD" "$branch_to_check" 2>/dev/null; then
#           echo "üîç [DRY RUN] Would skip deletion of branch '$branch_to_check' (has changes)"
#         else
#           # Check if branch is ahead/behind or has different commits
#           local base_commit=$(git merge-base "HEAD" "$branch_to_check" 2>/dev/null)
#           if [[ -n "$base_commit" ]] && git diff --quiet "$base_commit" "$branch_to_check" 2>/dev/null; then
#             echo "üîç [DRY RUN] Would delete branch: $branch_to_check"
#           else
#             echo "üîç [DRY RUN] Would skip deletion of branch '$branch_to_check' (has diverged)"
#           fi
#         fi
#       fi
#     fi
#   else
#     # Check if we can safely delete the branch BEFORE removing the worktree
#     local can_delete_branch=false
#     local branch_deletion_reason=""
#     
#     if [[ -n "$branch_to_check" ]]; then
#       # Safeguard: Never delete main/master branches
#       if [[ "$branch_to_check" == "main" || "$branch_to_check" == "master" ]]; then
#         branch_deletion_reason="main branch"
#       else
#         # Check if branch has uncommitted changes
#         if ! git diff --quiet "HEAD" "$branch_to_check" 2>/dev/null; then
#           branch_deletion_reason="has changes"
#         else
#           # Check if branch is ahead/behind or has different commits
#           local base_commit=$(git merge-base "HEAD" "$branch_to_check" 2>/dev/null)
#           if [[ -n "$base_commit" ]] && git diff --quiet "$base_commit" "$branch_to_check" 2>/dev/null; then
#             can_delete_branch=true
#           else
#             branch_deletion_reason="has diverged"
#           fi
#         fi
#       fi
#     fi
#     
#     # Check if we're currently in the worktree being removed
#     local current_dir="$(pwd)"
#     local main_worktree="$(_gtr_get_main_worktree)"
#     local need_to_cd_back=false
#     
#     if [[ "$current_dir" == "$worktree_path" ]]; then
#       echo "üîÑ Currently in worktree being removed, changing to main repository..."
#       cd "$main_worktree" || {
#         echo "‚ùå Failed to change to main repository directory"
#         return 1
#       }
#       need_to_cd_back=true
#     fi
#     
#     # Only remove the worktree if we can delete the branch OR force is used
#     if [[ "$can_delete_branch" == "true" || "$force" == "true" ]]; then
#       # Remove the worktree
#       if git worktree remove "$worktree_path"; then
#         echo "Removed worktree '$name'"
# 
#         # Now handle branch deletion based on our earlier checks
#         if [[ -n "$branch_to_check" ]]; then
#           if [[ "$can_delete_branch" == "true" ]]; then
#             # Always ask for confirmation if this is a fallback branch, even with --force
#             if [[ "$is_fallback" == "true" ]]; then
#               printf "Delete branch '$branch_to_check' (no changes)? [y/N] "
#               read -r reply
#               case "$reply" in
#                 [yY]|[yY][eE][sS])
#                   echo "Deleting branch '$branch_to_check'"
#                   git branch -d "$branch_to_check" 2>/dev/null || echo "Could not delete branch '$branch_to_check'"
#                   ;;
#                 *)
#                   echo "Skipped deleting branch '$branch_to_check'"
#                   ;;
#               esac
#             elif [[ "$force" == "true" ]]; then
#               echo "Deleting branch '$branch_to_check' (no changes)"
#               git branch -d "$branch_to_check" 2>/dev/null || echo "Could not delete branch '$branch_to_check'"
#             else
#               printf "Delete branch '$branch_to_check' (no changes)? [y/N] "
#               read -r reply
#               case "$reply" in
#                 [yY]|[yY][eE][sS])
#                   echo "Deleting branch '$branch_to_check'"
#                   git branch -d "$branch_to_check" 2>/dev/null || echo "Could not delete branch '$branch_to_check'"
#                   ;;
#                 *)
#                   echo "Skipped deleting branch '$branch_to_check'"
#                   ;;
#               esac
#             fi
#           else
#             echo "Branch '$branch_to_check' $branch_deletion_reason. Not deleting."
#           fi
#         fi
# 
#         # If we changed directories, we can't go back to the original worktree since it's deleted
#         if [[ "$need_to_cd_back" == "true" ]]; then
#           echo "‚úÖ Worktree removed successfully. You're now in the main repository."
#         fi
#       else
#         echo "Failed to remove worktree '$name'"
# 
#         # If we changed directories and removal failed, change back to original directory
#         if [[ "$need_to_cd_back" == "true" ]]; then
#           echo "üîÑ Changing back to original worktree directory..."
#           cd "$current_dir" || echo "‚ö†Ô∏è  Could not change back to original directory"
#         fi
#       fi
#     else
#       # Worktree removal blocked because branch can't be safely deleted
#       if [[ -n "$branch_to_check" ]]; then
#         echo "‚ùå Cannot remove worktree '$name'"
#         echo "   Branch '$branch_to_check' $branch_deletion_reason."
#         echo "   Use --force to remove anyway."
#       else
#         echo "‚ùå Cannot remove worktree '$name' (no associated branch found)"
#         echo "   Use --force to remove anyway."
#       fi
# 
#       # If we changed directories, change back to original directory
#       if [[ "$need_to_cd_back" == "true" ]]; then
#         echo "üîÑ Changing back to original worktree directory..."
#         cd "$current_dir" || echo "‚ö†Ô∏è  Could not change back to original directory"
#       fi
#     fi
#   fi
# }

_gtr_prune_worktrees() {
  local base_branch="${_GTR_BASE_BRANCH:-main}"
  local dry_run="${_GTR_DRY_RUN:-false}"
  local force="${_GTR_FORCE:-false}"
  local base="$(_gtr_get_base_dir)"
  local main_worktree="$(_gtr_get_main_worktree)"
  
  echo "üßπ Cleaning up merged worktrees (base: $base_branch)..."
  
  # Parse worktrees using a more robust approach
  local -a worktree_paths
  local -a branch_names
  
  # Read worktree data into arrays
  while IFS='|' read -r worktree_path branch_name; do
    if [[ -n "$worktree_path" && -n "$branch_name" ]]; then
      worktree_paths+=("$worktree_path")
      branch_names+=("$branch_name")
    fi
  done < <(git worktree list --porcelain | awk -v main_worktree="$main_worktree" '
    /^worktree / {
      worktree_path = $2
      if (worktree_path != main_worktree) {
        worktrees[worktree_path] = ""
      }
    }
    /^branch refs\/heads\// {
      if (worktree_path != main_worktree) {
        worktrees[worktree_path] = substr($0, 19)  # Remove "branch refs/heads/"
      }
    }
    END {
      for (wt in worktrees) {
        if (worktrees[wt] != "") {
          print wt "|" worktrees[wt]
        }
      }
    }
  ')
  
  # Process each worktree
  for i in "${!worktree_paths[@]}"; do
    local worktree_path="${worktree_paths[$i]}"
    local branch_name="${branch_names[$i]}"
    
    local should_remove=false
    local reason=""
    
    # Check if branch is merged using multiple strategies
    if git branch --merged "$base_branch" | grep -q "^[[:space:]]*$branch_name$"; then
      should_remove=true
      reason="merged into $base_branch"
    elif git merge-base --is-ancestor "$branch_name" "$base_branch" 2>/dev/null; then
      should_remove=true
      reason="ancestor of $base_branch"
    else
      # Check if the branch's commits are all in the base branch (squash merge case)
      local branch_commits=$(git rev-list "$branch_name" --not "$base_branch" 2>/dev/null | wc -l)
      if [[ "$branch_commits" -eq 0 ]]; then
        should_remove=true
        reason="all commits present in $base_branch (squash merged)"
      fi
    fi
    
    if [[ "$should_remove" == "true" ]]; then
      if [[ "$dry_run" == "true" ]]; then
        echo "üîç [DRY RUN] Would remove: $worktree_path ($branch_name) - $reason"
      else
        if [[ "$force" == "true" ]]; then
          echo "üóëÔ∏è  Removing: $worktree_path ($branch_name) - $reason"
          git worktree remove "$worktree_path" 2>/dev/null && \
          git branch -d "$branch_name" 2>/dev/null || \
          echo "‚ö†Ô∏è  Could not remove worktree or branch: $worktree_path ($branch_name)"
        else
          local reply
          reply=$(_gtr_ask_user "Remove worktree '$worktree_path' ($branch_name) - $reason? [y/N] " "N")
          case "$reply" in
            [yY]|[yY][eE][sS])
              echo "üóëÔ∏è  Removing: $worktree_path ($branch_name)"
              git worktree remove "$worktree_path" 2>/dev/null && \
              git branch -d "$branch_name" 2>/dev/null || \
              echo "‚ö†Ô∏è  Could not remove worktree or branch: $worktree_path ($branch_name)"
              ;;
            *)
              echo "‚è≠Ô∏è  Skipped: $worktree_path ($branch_name)"
              ;;
          esac
        fi
      fi
    else
      echo "‚úÖ Keeping: $worktree_path ($branch_name) - not merged"
    fi
  done
  
  if [[ "$dry_run" == "true" ]]; then
    echo "üîç Dry run complete! Use without --dry-run to actually remove worktrees."
  else
    echo "‚ú® Cleanup complete!"
  fi
}

# Public command functions
gtr_create() {
  # Check if configuration exists (either global or local)
  if ! _gtr_is_initialized; then
    echo "‚ùå No gtr configuration found"
    echo "   Run 'gtr init' to create a global configuration (~/.gtr/config)"
    echo "   or create a local configuration in this repository (.gtr/config)"
    return 1
  fi

  # Use the global base_branch variable, default to current branch if not set
  if [[ -z "$_GTR_BASE_BRANCH" ]]; then
    _GTR_BASE_BRANCH=$(git rev-parse --abbrev-ref HEAD)
  fi

  for name in "${_GTR_ARGS[@]}"; do
    _gtr_create_worktree "$name"
  done
}

gtr_remove() {
  local force="false"
  local dry_run="false"
  local names=()
  
  # Check for flags and separate them from names
  for arg in "${_GTR_ARGS[@]}"; do
    if [[ "$arg" == "--force" ]]; then
      force="true"
    elif [[ "$arg" == "--dry-run" ]]; then
      dry_run="true"
    else
      names+=("$arg")
    fi
  done
  
  # If no worktree names provided, check if we're in a worktree
  if [[ ${#names[@]} -eq 0 ]]; then
    local current_dir="$(pwd)"
    local git_dir=$(git rev-parse --git-dir 2>/dev/null)
    
    if [[ -n "$git_dir" && "$git_dir" == *"/.git/worktrees/"* ]]; then
      # We're in a worktree, extract the worktree name
      local worktree_name=$(basename "$current_dir")
      echo "üîç No worktree specified, detected current worktree: $worktree_name"
      names+=("$worktree_name")
    else
      echo "‚ùå No worktree specified and not currently in a worktree"
      echo "üí° Usage: gtr rm <worktree-name> or run from within a worktree"
      echo "üí° Available worktrees:"
      git worktree list
      return 1
    fi
  fi
  
  for name in "${names[@]}"; do
    _gtr_remove_worktree "$name" "$force" "$dry_run"
  done
  
  if [[ "$dry_run" == "true" ]]; then
    echo "üîç Dry run complete! Use without --dry-run to actually remove worktrees."
  fi
}

gtr_cd() {
  local name=""
  if [[ ${#_GTR_ARGS[@]} -gt 0 ]]; then
    name="${_GTR_ARGS[1]}"
  fi
  local base="$(_gtr_get_base_dir)"
  
  if [[ -z "$name" ]]; then
    echo "Usage: gtr cd <name>"
    return 1
  fi
  
  cd "$base/$name" || { echo "No such worktree: $base/$name"; return 1; }
}

gtr_list() {
  git worktree list
}

gtr_claude() {
  local name=""
  local claude_args=()
  if [[ ${#_GTR_ARGS[@]} -gt 0 ]]; then
    name="${_GTR_ARGS[0]}"
  fi
  if [[ ${#_GTR_EXTRA_ARGS[@]} -gt 0 ]]; then
    claude_args=("${_GTR_EXTRA_ARGS[@]}")
  fi

  if [[ -z "$name" ]]; then
    echo "Usage: gtr claude <name> [-- <claude_args>...]"
    return 1
  fi

  local dir
  dir=$(_gtr_find_or_create_worktree "$name") || return 1

  if [[ ${#claude_args[@]} -gt 0 ]]; then
    ( cd "$dir" && claude "${claude_args[@]}" )
  else
    ( cd "$dir" && claude )
  fi
}

gtr_cursor() {
  local name=""
  local cursor_args=()
  if [[ ${#_GTR_ARGS[@]} -gt 0 ]]; then
    name="${_GTR_ARGS[0]}"
  fi
  if [[ ${#_GTR_EXTRA_ARGS[@]} -gt 0 ]]; then
    cursor_args=("${_GTR_EXTRA_ARGS[@]}")
  fi

  if [[ -z "$name" ]]; then
    echo "Usage: gtr cursor <name> [-- <cursor_args>...]"
    return 1
  fi

  local dir
  dir=$(_gtr_find_or_create_worktree "$name") || return 1

  if [[ ${#cursor_args[@]} -gt 0 ]]; then
    ( cd "$dir" && cursor "${cursor_args[@]}" )
  else
    ( cd "$dir" && cursor )
  fi
}

gtr_prune() {
  local base_branch="main"
  local dry_run="false"
  local force="false"
  
  # Parse prune-specific flags
  for arg in "${_GTR_ARGS[@]}"; do
    case "$arg" in
      --base)
        # This won't work in a simple loop, but we'll handle it in the main function
        ;;
      --dry-run)
        dry_run="true"
        ;;
      --force)
        force="true"
        ;;
    esac
  done
  
  # Handle --base flag properly
  local i=0
  while [[ $i -lt ${#_GTR_ARGS[@]} ]]; do
    if [[ "${_GTR_ARGS[$i]}" == "--base" && $((i+1)) -lt ${#_GTR_ARGS[@]} ]]; then
      base_branch="${_GTR_ARGS[$((i+1))]}"
      i=$((i+2))
    else
      i=$((i+1))
    fi
  done
  
  export _GTR_BASE_BRANCH="$base_branch"
  export _GTR_DRY_RUN="$dry_run"
  export _GTR_FORCE="$force"
  
  _gtr_prune_worktrees
}

_gtr_init_global_config() {
  local global_config_dir="$1"
  local global_config_file="$2"

  echo "üîß Initializing global gtr configuration..."

  # Create ~/.gtr directory
  if [[ ! -d "$global_config_dir" ]]; then
    mkdir -p "$global_config_dir"
    echo "üìÅ Created ~/.gtr directory"
  fi

  # Create global config file
  _gtr_create_default_config "$global_config_file"
  echo "üìù Created global configuration file at $global_config_file"
  echo "‚úÖ Global gtr configuration initialized!"
}

_gtr_init_config_with_options() {
  local config_dir="$1"
  local config_file="$2"
  local config_type="$3"  # "global" or "local"

  echo "üîß Initializing $config_type gtr configuration..."

  # Create directory if it doesn't exist
  if [[ ! -d "$config_dir" ]]; then
    mkdir -p "$config_dir"
    echo "üìÅ Created $config_dir directory"
  fi

  # Handle existing config file
  if [[ -f "$config_file" ]]; then
    echo "‚ö†Ô∏è  Configuration file already exists: $config_file"
    echo ""
    echo "What would you like to do?"
    echo "  [o]verwrite - Replace with default configuration"
    echo "  [d]iff      - Show diff between current and default"
    echo "  [m]erge     - Merge default settings into current config"
    echo "  [s]kip      - Keep existing configuration"
    echo ""

    while true; do
      printf "Choose [overwrite/diff/merge/skip]: "
      read -r choice
      if [[ -z "$choice" ]]; then
        choice="skip"
      fi

      case "$choice" in
        [oO]|overwrite)
          echo "üîÑ Overwriting configuration file..."
          _gtr_create_default_config "$config_file"
          echo "‚úÖ Configuration file overwritten"
          break
          ;;
        [dD]|diff)
          _gtr_show_config_diff "$config_file"
          # Ask again after showing diff
          ;;
        [mM]|merge)
          _gtr_merge_config "$config_file"
          echo "‚úÖ Configuration file merged"
          break
          ;;
        [sS]|skip)
          echo "‚è≠Ô∏è  Keeping existing configuration"
          break
          ;;
        *)
          echo "Invalid choice. Please choose overwrite, diff, merge, or skip."
          ;;
      esac
    done
  else
    _gtr_create_default_config "$config_file"
    echo "üìù Created default $config_type configuration file"
  fi

  echo "‚úÖ $config_type gtr configuration initialized successfully!"
  echo "   Config file: $config_file"
  echo "   Edit this file to customize gtr behavior"
}

gtr_init() {
  local init_doctor="${_GTR_INIT_DOCTOR:-false}"
  local init_fix="${_GTR_INIT_FIX:-false}"
  local current_dir="$(pwd)"
  local global_config_dir="$HOME/.gtr"
  local global_config_file="$global_config_dir/config"
  local local_config_dir="$current_dir/.gtr"
  local local_config_file="$local_config_dir/config"

  if [[ "$init_doctor" == "true" ]]; then
    # For doctor mode, check the config that would be used
    local config_file="$local_config_file"
    if [[ ! -f "$local_config_file" && -f "$global_config_file" ]]; then
      config_file="$global_config_file"
    fi
    _gtr_init_doctor "$current_dir" "$config_file" "$init_fix"
  else
    # Ask about global config first
    if [[ ! -f "$global_config_file" ]]; then
      echo "üîß No global gtr configuration found at ~/.gtr/config"
      echo ""
      printf "Create global config? [Y/n] "
      read -r choice
      if [[ -z "$choice" ]]; then
        choice="Y"
      fi
      case "$choice" in
        [nN]|[nN][oO])
          echo "‚è≠Ô∏è  Skipping global configuration"
          ;;
        *)
          _gtr_init_global_config "$global_config_dir" "$global_config_file"
          ;;
      esac
    else
      echo "üìã Global config already exists: $global_config_file"
      echo ""
      echo "What would you like to do with the global config?"
      echo "  [k]eep    - Keep existing global configuration"
      echo "  [u]pdate  - Update/recreate global configuration"
      echo "  [d]iff    - Show diff between current and default"
      echo ""

      printf "Choose [keep/update/diff]: "
      read -r choice
      if [[ -z "$choice" ]]; then
        choice="keep"
      fi
      case "$choice" in
        [uU]|update)
          _gtr_init_config_with_options "$global_config_dir" "$global_config_file" "global"
          ;;
        [dD]|diff)
          _gtr_show_config_diff "$global_config_file"
          ;;
        *)
          echo "‚úÖ Keeping existing global configuration"
          ;;
      esac
    fi

    echo ""

    # Ask about local config
    if [[ ! -f "$local_config_file" ]]; then
      echo "ü§î Would you like to create a local .gtr/config for this repository?"
      echo "   This will override the global config (~/.gtr/config) for this repo only."
      echo ""

      printf "Create local config? [y/N] "
      read -r choice
      if [[ -z "$choice" ]]; then
        choice="N"
      fi
      case "$choice" in
        [yY]|[yY][eE][sS])
          _gtr_init_config "$current_dir" "$local_config_dir" "$local_config_file"
          ;;
        *)
          echo "‚úÖ Using global configuration at $global_config_file"
          ;;
      esac
    else
      echo "üìã Local config already exists: $local_config_file"
      _gtr_init_config "$current_dir" "$local_config_dir" "$local_config_file"
    fi
  fi
}

_gtr_copy_hooks_to_local() {
  local main_worktree="$1"
  local config_dir="$2"
  local hooks_dir="$config_dir/hooks"
  local source_hooks_dir=""
  
  # Find the source hooks directory (from the gtr installation)
  # Try to find it relative to the current script location
  local script_dir=""
  if [[ -n "${BASH_SOURCE[0]}" ]]; then
    script_dir="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"
  else
    # Fallback: try to find it from the current working directory
    script_dir="$(pwd)"
  fi
  
  # Look for hooks in common locations
  # First try relative to script location
  for potential_dir in "$script_dir/../dot_gtr/hooks" "$script_dir/../../dot_gtr/hooks" "$(dirname "$script_dir")/dot_gtr/hooks"; do
    if [[ -d "$potential_dir" ]]; then
      source_hooks_dir="$potential_dir"
      break
    fi
  done
  
  # If not found, try to find gtr installation directory
  if [[ -z "$source_hooks_dir" ]]; then
    local gtr_script=""
    if command -v gtr >/dev/null 2>&1; then
      gtr_script="$(which gtr)"
      if [[ -L "$gtr_script" ]]; then
        gtr_script="$(readlink "$gtr_script")"
      fi
      local gtr_dir="$(dirname "$gtr_script")"
      for potential_dir in "$gtr_dir/../dot_gtr/hooks" "$gtr_dir/../../dot_gtr/hooks" "$(dirname "$gtr_dir")/dot_gtr/hooks"; do
        if [[ -d "$potential_dir" ]]; then
          source_hooks_dir="$potential_dir"
          break
        fi
      done
    fi
  fi
  
  # Final fallback: look in current directory and common development locations
  if [[ -z "$source_hooks_dir" ]]; then
    for potential_dir in "$(pwd)/dot_gtr/hooks" "/Users/ryanwjackson/Documents/dev/worktrees/init-hooks/dot_gtr/hooks"; do
      if [[ -d "$potential_dir" ]]; then
        source_hooks_dir="$potential_dir"
        break
      fi
    done
  fi
  
  if [[ -z "$source_hooks_dir" || ! -d "$source_hooks_dir" ]]; then
    echo "‚ö†Ô∏è  Could not find source hooks directory, skipping hooks setup"
    return 0
  fi
  
  # Create hooks directory in local config
  if [[ ! -d "$hooks_dir" ]]; then
    mkdir -p "$hooks_dir"
    echo "üìÅ Created hooks directory: $hooks_dir"
  fi
  
  # Copy sample hooks
  local copied_hooks=()
  for hook_file in "$source_hooks_dir"/*.sample; do
    if [[ -f "$hook_file" ]]; then
      local hook_name="$(basename "$hook_file" .sample)"
      local target_file="$hooks_dir/$hook_name"
      
      if [[ ! -f "$target_file" ]]; then
        if cp "$hook_file" "$target_file" 2>/dev/null; then
          chmod +x "$target_file" 2>/dev/null
          copied_hooks+=("$hook_name")
        fi
      fi
    fi
  done
  
  if [[ ${#copied_hooks[@]} -gt 0 ]]; then
    echo "üîß Copied hooks to local config:"
    for hook in "${copied_hooks[@]}"; do
      echo "  - $hook"
    done
    echo "   Edit hooks in: $hooks_dir"
  else
    echo "üìã Hooks already exist in local config"
  fi
}

_gtr_init_config() {
  local main_worktree="$1"
  local config_dir="$2"
  local config_file="$3"
  
  echo "üîß Initializing gtr configuration..."
  
  # Create .gtr directory
  if [[ ! -d "$config_dir" ]]; then
    mkdir -p "$config_dir"
    echo "üìÅ Created .gtr directory"
  fi
  
  # Handle existing config file
  if [[ -f "$config_file" ]]; then
    echo "‚ö†Ô∏è  Configuration file already exists: $config_file"
    echo ""
    echo "What would you like to do?"
    echo "  [o]verwrite - Replace with default configuration"
    echo "  [d]iff      - Show diff between current and default"
    echo "  [m]erge     - Merge default settings into current config"
    echo "  [s]kip      - Keep existing configuration"
    echo ""
    
    while true; do
      printf "Choose [overwrite/diff/merge/skip]: "
      read -r choice
      if [[ -z "$choice" ]]; then
        choice="skip"
      fi

      case "$choice" in
        [oO]|overwrite)
          echo "üîÑ Overwriting configuration file..."
          _gtr_create_default_config "$config_file"
          echo "‚úÖ Configuration file overwritten"
          break
          ;;
        [dD]|diff)
          _gtr_show_config_diff "$config_file"
          # Ask again after showing diff
          ;;
        [mM]|merge)
          _gtr_merge_config "$config_file"
          echo "‚úÖ Configuration file merged"
          break
          ;;
        [sS]|skip)
          echo "‚è≠Ô∏è  Keeping existing configuration"
          break
          ;;
        *)
          echo "Invalid choice. Please choose overwrite, diff, merge, or skip."
          ;;
      esac
    done
  else
    _gtr_create_default_config "$config_file"
    echo "üìù Created default configuration file"
  fi
  
  # Copy hooks if this is a local config initialization
  _gtr_copy_hooks_to_local "$main_worktree" "$config_dir"
  
  echo "‚úÖ gtr configuration initialized successfully!"
  echo "   Config file: $config_file"
  echo "   Edit this file to customize gtr behavior"
}

_gtr_create_default_config() {
  local config_file="$1"
  cat > "$config_file" << 'EOF'
# gtr configuration file
# This file defines gtr behavior and which files should be copied to worktrees

[files_to_copy]
# File patterns to copy (glob patterns, one per line)
# Default patterns for local environment files
.env*local*
.env.*local*

# Claude settings directories
.claude/
.anthropic/

# Add more patterns as needed
# Example:
# config/local.json
# secrets/*.local

[settings]
# Default editor to open worktrees
editor=cursor


# Whether to run pnpm commands by default
run_pnpm=true

# Whether to open editor after creating worktree
auto_open=true

# Base directory for worktrees (relative to main repo or absolute path)
# worktree_base=../worktrees

[doctor]
# Whether to show detailed diff information
show_detailed_diffs=false

# Whether to auto-fix missing files without prompts
auto_fix=false
EOF
}

_gtr_show_config_diff() {
  local config_file="$1"
  local temp_file=$(mktemp)
  
  _gtr_create_default_config "$temp_file"
  
  echo "üìã Showing diff between current and default configuration:"
  echo "  Current: $config_file"
  echo "  Default: (temporary)"
  echo ""
  
  if command -v diff >/dev/null 2>&1; then
    diff -u "$config_file" "$temp_file" || true
  else
    echo "‚ö†Ô∏è  diff command not available"
  fi
  
  rm -f "$temp_file"
  echo ""
}

_gtr_merge_config() {
  local config_file="$1"
  local temp_file=$(mktemp)
  local backup_file="${config_file}.backup.$(date +%s)"
  
  # Create backup
  cp "$config_file" "$backup_file"
  echo "üìã Created backup: $backup_file"
  
  # Create default config
  _gtr_create_default_config "$temp_file"
  
  # Merge using diff3 if available, otherwise simple append
  if command -v diff3 >/dev/null 2>&1; then
    if diff3 -m "$config_file" "$temp_file" "$config_file" > "${config_file}.merged" 2>/dev/null; then
      mv "${config_file}.merged" "$config_file"
      echo "‚úÖ Successfully merged using diff3"
    else
      echo "‚ö†Ô∏è  diff3 merge failed, using simple merge strategy"
      _gtr_simple_merge_config "$config_file" "$temp_file"
    fi
  else
    echo "üìù Using simple merge strategy"
    _gtr_simple_merge_config "$config_file" "$temp_file"
  fi
  
  rm -f "$temp_file"
}

_gtr_simple_merge_config() {
  local config_file="$1"
  local temp_file="$2"
  
  # Simple merge: append missing sections from default config
  echo "" >> "$config_file"
  echo "# Merged settings from default configuration" >> "$config_file"
  
  # Check if [files_to_copy] section exists
  if ! grep -q "^\[files_to_copy\]" "$config_file"; then
    echo "" >> "$config_file"
    echo "[files_to_copy]" >> "$config_file"
    sed -n '/^\[files_to_copy\]/,/^\[/p' "$temp_file" | grep -v "^\[" | grep -v "^$" >> "$config_file"
  fi
  
  # Check if [settings] section exists
  if ! grep -q "^\[settings\]" "$config_file"; then
    echo "" >> "$config_file"
    echo "[settings]" >> "$config_file"
    sed -n '/^\[settings\]/,/^\[/p' "$temp_file" | grep -v "^\[" | grep -v "^$" >> "$config_file"
  fi
  
  # Check if [doctor] section exists
  if ! grep -q "^\[doctor\]" "$config_file"; then
    echo "" >> "$config_file"
    echo "[doctor]" >> "$config_file"
    sed -n '/^\[doctor\]/,/^\[/p' "$temp_file" | grep -v "^\[" | grep -v "^$" >> "$config_file"
  fi
  
  echo "‚úÖ Configuration merged (manual review recommended)"
}

_gtr_init_doctor() {
  local main_worktree="$1"
  local config_file="$2"
  local init_fix="$3"
  
  echo "üîç Checking gtr configuration..."
  
  if [[ ! -f "$config_file" ]]; then
    echo "‚ùå No configuration file found at $config_file"
    echo "   Run 'gtr init' first to create the configuration"
    return 1
  fi
  
  # Test if the config file can be read without errors
  local test_patterns
  local error_output
  error_output=$(_gtr_read_config "$main_worktree" 2>&1)
  local exit_code=$?
  
  # Check if there were regex errors in the output
  if [[ "$error_output" == *"failed to compile regex"* ]] || [[ $exit_code -ne 0 ]]; then
    echo "‚ùå The configuration file appears to be malformed or corrupted."
    echo "üîß Automatically repairing the configuration file..."
    
    if _gtr_repair_config "$config_file"; then
      echo "‚úÖ Configuration file has been repaired. Continuing with doctor check..."
    else
      echo "‚ùå Unable to repair configuration file. Please resolve the issue manually."
      return 1
    fi
  fi
  
  # Read configuration patterns
  local config_patterns=($(_gtr_read_config "$main_worktree"))
  
  if [[ ${#config_patterns[@]} -eq 0 ]]; then
    echo "‚ö†Ô∏è  No patterns found in configuration file"
    return 1
  fi
  
  echo "üìã Current configuration patterns:"
  for pattern in "${config_patterns[@]}"; do
    echo "  - $pattern"
  done
  echo ""
  
  # Find all local files that match patterns
  local matching_files=()
  local unmatched_files=()
  
  for pattern in "${config_patterns[@]}"; do
    while IFS= read -r -d '' file; do
      if [[ -f "$file" ]]; then
        local relative_path="${file#$main_worktree/}"
        matching_files+=("$relative_path")
      fi
    done < <(find "$main_worktree" -name "$pattern" -type f -print0 2>/dev/null)
  done
  
  # Find all local files that don't match any pattern (exclude common directories)
  while IFS= read -r -d '' file; do
    if [[ -f "$file" ]]; then
      local relative_path="${file#$main_worktree/}"
      # Skip common directories that shouldn't be copied
      if [[ "$relative_path" == *node_modules/* || 
            "$relative_path" == */.next/* || 
            "$relative_path" == .git/* || 
            "$relative_path" == dist/* || 
            "$relative_path" == build/* || 
            "$relative_path" == */.pnpm/* ]]; then
        continue
      fi
      
      local matched=false
      for pattern in "${config_patterns[@]}"; do
        if [[ "$relative_path" == $pattern || "$(basename "$relative_path")" == $pattern ]]; then
          matched=true
          break
        fi
      done
      if [[ "$matched" == "false" ]]; then
        unmatched_files+=("$relative_path")
      fi
    fi
  done < <(find "$main_worktree" -name "*local*" -type f -print0 2>/dev/null)
  
  echo "üìä Analysis results:"
  echo "  Files matching config: ${#matching_files[@]}"
  echo "  Local files not in config: ${#unmatched_files[@]}"
  echo ""
  
  if [[ ${#matching_files[@]} -gt 0 ]]; then
    echo "‚úÖ Files that will be copied to worktrees:"
    for file in "${matching_files[@]}"; do
      echo "  - $file"
    done
    echo ""
  fi
  
  if [[ ${#unmatched_files[@]} -gt 0 ]]; then
    echo "‚ö†Ô∏è  Local files that won't be copied (not in config):"
    for file in "${unmatched_files[@]}"; do
      echo "  - $file"
    done
    echo ""
    
    if [[ "$init_fix" == "true" ]]; then
      echo "üîß Adding unmatched files to configuration..."
      for file in "${unmatched_files[@]}"; do
        echo "$file" >> "$config_file"
        echo "  Added: $file"
      done
      echo "‚úÖ Configuration updated!"
    else
      echo "üí° To add these files to the configuration, run:"
      echo "   gtr init --doctor --fix"
    fi
  else
    echo "‚úÖ All local files are covered by the configuration"
  fi
}

gtr_doctor() {
  local worktree_name=""
  if [[ ${#_GTR_ARGS[@]} -gt 0 ]]; then
    worktree_name="${_GTR_ARGS[1]}"
  fi
  local fix_mode="${_GTR_FIX_MODE:-false}"
  local force_mode="${_GTR_FORCE_MODE:-false}"
  local username="${_GTR_USERNAME:-$(whoami)}"
  local current_dir="$(pwd)"
  
  # Detect if we're in a worktree or main repo
  local git_dir=$(git rev-parse --git-dir)
  local is_worktree=false
  local main_worktree=""
  local worktree_path=""
  
  if [[ "$git_dir" == *"/.git/worktrees/"* ]]; then
    # We're in a worktree
    is_worktree=true
    main_worktree=$(dirname "$(dirname "$(dirname "$git_dir")")")
    worktree_path="$current_dir"
    echo "üîç Running from worktree: $worktree_path"
  else
    # We're in the main repository
    is_worktree=false
    main_worktree="$current_dir"
    echo "üîç Running from main repository: $main_worktree"
  fi
  
  # If worktree name provided, find that specific worktree
  if [[ -n "$worktree_name" ]]; then
    if [[ "$worktree_name" == *"/"* ]]; then
      # Full worktree path provided
      worktree_path="$worktree_name"
    else
      # Just the name, try to find the worktree using git worktree list
      worktree_path=$(git worktree list --porcelain | awk -v name="$worktree_name" '
        /^worktree / { worktree_path = $2 }
        /^branch refs\/heads\// { 
          branch = substr($0, 19)
          if (branch ~ name || worktree_path ~ name) {
            print worktree_path
            exit
          }
        }
      ')
      
      if [[ -z "$worktree_path" ]]; then
        echo "‚ùå Worktree not found: $worktree_name"
        echo "üí° Available worktrees:"
        git worktree list
        return 1
      fi
    fi
    
    if [[ ! -d "$worktree_path" ]]; then
      echo "‚ùå Worktree not found: $worktree_path"
      echo "üí° Available worktrees:"
      git worktree list
      return 1
    fi
  elif [[ "$is_worktree" == "false" ]]; then
    # Running from main repo without specifying worktree name
    echo "Usage: gtr doctor [WORKTREE_NAME] [--fix] [--username USERNAME]"
    echo "  WORKTREE_NAME: Name of the worktree to check"
    echo "  When run from main repo, WORKTREE_NAME is required"
    return 1
  fi
  
  echo "üìã Source (main repo): $main_worktree"
  echo "üìã Target (worktree): $worktree_path"
  echo ""
  
  local missing_files=()
  local different_files=()
  local missing_dirs=()
  
  # Read configuration patterns
  local patterns=($(_gtr_read_config "$main_worktree"))
  
  # Check files and directories based on configuration
  for pattern in "${patterns[@]}"; do
    if [[ "$pattern" == */ ]]; then
      # Directory pattern
      local dir_name="${pattern%/}"
      if [[ -d "$main_worktree/$dir_name" ]]; then
        if [[ ! -d "$worktree_path/$dir_name" ]]; then
          missing_dirs+=("$dir_name/")
        fi
      fi
    else
      # File pattern - use find to search recursively
      while IFS= read -r -d '' file; do
        if [[ -f "$file" ]]; then
          local relative_path="${file#$main_worktree/}"
          local target_file="$worktree_path/$relative_path"
          if [[ ! -f "$target_file" ]]; then
            missing_files+=("$relative_path")
          elif _gtr_files_different "$file" "$target_file"; then
            different_files+=("$relative_path")
          fi
        fi
      done < <(find "$main_worktree" -name "$pattern" -type f -print0 2>/dev/null)
    fi
  done
  
  # Report findings
  if [[ ${#missing_files[@]} -eq 0 && ${#different_files[@]} -eq 0 && ${#missing_dirs[@]} -eq 0 ]]; then
    echo "‚úÖ All local files are present and up-to-date in the worktree"
    return 0
  fi
  
  if [[ ${#missing_files[@]} -gt 0 ]]; then
    echo "‚ùå Missing files in worktree:"
    for file in "${missing_files[@]}"; do
      echo "  - $file"
    done
  fi
  
  if [[ ${#different_files[@]} -gt 0 ]]; then
    echo "‚ö†Ô∏è  Different files in worktree:"
    for file in "${different_files[@]}"; do
      echo "  - $file"
    done
  fi
  
  if [[ ${#missing_dirs[@]} -gt 0 ]]; then
    echo "‚ùå Missing directories in worktree:"
    for dir in "${missing_dirs[@]}"; do
      echo "  - $dir"
    done
  fi
  
  if [[ "$fix_mode" == "true" ]]; then
    echo ""
    echo "üîß Fixing files..."
    _gtr_copy_local_files "$main_worktree" "$worktree_path" "$force_mode" "$main_worktree"
    echo "‚úÖ Fix complete!"
  else
    echo ""
    echo "üí° To fix files, run:"
    if [[ ${#different_files[@]} -gt 0 ]]; then
      echo "   gtr doctor $worktree_name --fix --username $username"
      echo "   (Use --force to skip interactive prompts for different files)"
    else
      echo "   gtr doctor $worktree_name --fix --username $username"
    fi
  fi
}


_gtr_show_help() {
  cat << 'EOF'
gtr - Git worktree helper

USAGE:
    gtr <COMMAND> [OPTIONS] [ARGS...]

COMMANDS:
    create, c <name>...           Create new worktrees
    remove, rm [name]...          Remove worktrees (with --force, --dry-run)
                                  If no name provided, removes current worktree
    cd <name>                     Change directory to worktree
    list, ls, l                   List all worktrees
    idea, i {create|list|open}    Manage idea files
    claude <name> [-- <args>...]  Run claude in worktree directory
    cursor <name> [-- <args>...]  Run cursor in worktree directory
    prune                         Clean up merged worktrees
    doctor [name]                 Check worktree for missing local files
    init                          Initialize gtr configuration
    --help, -h                    Show this help message
    --version, -v                 Show version

GLOBAL OPTIONS:
    --username <USERNAME>         Set username for branch naming (default: current user)
    --editor <EDITOR>             Set editor to open worktrees (default: cursor)
    --no-open                     Don't open editor after creating worktree
    --no-install                  Skip pnpm commands during worktree creation
    --base <BRANCH>               Base branch for worktree creation (default: current branch)
    --untracked <true|false>      Include untracked changes in worktree (default: true)

EXAMPLES:
    # Create worktrees
    gtr create feature0                    # Create worktree based on current branch
    gtr create feat1 feat2                 # Create multiple worktrees
    gtr create feature0 --base main        # Create worktree based on main branch
    gtr create feature0 --no-install       # Skip pnpm commands
    gtr create feature0 --no-open          # Don't open editor
    gtr create feature0 --untracked false  # Don't include untracked changes
    gtr create feature0 --base main --untracked false  # Create from main without untracked

    # Manage worktrees
    gtr list                               # List all worktrees
    gtr cd feature0                        # Navigate to worktree
    gtr claude feature0                    # Run claude in worktree
    gtr cursor feature0                    # Run cursor in worktree

    # Manage ideas
    gtr idea create                        # Create new idea (prompt for summary)
    gtr idea create 'New feature'          # Create idea with summary
    gtr idea create 'New feature' --less   # Create idea and open with less
    gtr idea list                          # List all ideas
    gtr idea list --mine                   # List your ideas
    gtr idea list --todo                   # List TODO ideas
    gtr idea open idea.md                  # Open idea file
    gtr idea open idea.md --less           # Open idea with less

    # Run tools with arguments
    gtr claude feature0 -- --model sonnet  # Run claude with specific model
    gtr cursor feature0 -- --new-window    # Run cursor with new window
    gtr claude feature0 -- --help          # Pass --help to claude

    # Cleanup
    gtr rm feature0                        # Remove worktree (with confirmation)
    gtr rm                                 # Remove current worktree (when inside one)
    gtr rm feature0 --force                # Force remove worktree
    gtr rm --dry-run                       # Show what would be removed (current worktree)
    gtr prune                              # Clean up merged worktrees
    gtr prune --base develop --force       # Clean up with custom base branch

    # Health check
    gtr doctor feature0                    # Check specific worktree
    gtr doctor                             # Check current directory (if it's a worktree)
    gtr doctor feature0 --fix              # Check and fix specific worktree
    gtr doctor --fix                       # Check and fix current worktree
    gtr doctor --fix --force               # Fix without interactive prompts

    # Configuration
    gtr init                               # Initialize gtr configuration
    gtr init --doctor                      # Check configuration coverage
    gtr init --doctor --fix                # Auto-add missing files to config

FEATURES:
    ‚Ä¢ Automatic copying of .env*local* files to new worktrees (recursive search)
    ‚Ä¢ Automatic copying of Claude settings (.claude/, .anthropic/)
    ‚Ä¢ Automatic pnpm approve-builds and pnpm install on creation
    ‚Ä¢ Smart branch naming with worktrees/repo_name/username/name pattern
    ‚Ä¢ Safe worktree removal with merge detection
    ‚Ä¢ Health checking with automatic fixing (recursive .env*local* detection)
    ‚Ä¢ Pass arguments to claude/cursor using -- delimiter

For more information, visit: https://medium.com/@dtunai/mastering-git-worktrees-with-claude-code-for-parallel-development-workflow-41dc91e645fe
EOF
}

 

# Main gtr function - dispatches to appropriate sub-commands
gtr() {
  # Handle global flags first (like --git-root)
  local git_root=""
  local args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --git-root)
        if [[ -n "$2" ]]; then
          git_root="$2"
          shift 2
        else
          echo "Error: --git-root requires a directory path"
          return 1
        fi
        ;;
      --git-root=*)
        git_root="${1#*=}"
        shift
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done

  # Change to git root if specified
  if [[ -n "$git_root" ]]; then
    if [[ ! -d "$git_root" ]]; then
      echo "Error: Git root directory does not exist: $git_root"
      return 1
    fi
    if ! cd "$git_root"; then
      echo "Error: Cannot change to git root directory: $git_root"
      return 1
    fi
    # Verify it's a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
      echo "Error: Directory is not a git repository: $git_root"
      return 1
    fi
  fi

  # Restore args and get command
  set -- "${args[@]}"
  local cmd="$1"

  # Handle version/help flags before parsing other arguments
  if [[ "$cmd" == "--version" || "$cmd" == "-v" ]]; then
    _gtr_print_version
    return 0
  fi

  # Handle help flag before parsing other arguments
  if [[ "$cmd" == "--help" || "$cmd" == "-h" ]]; then
    _gtr_show_help
    return 0
  fi

  shift || { echo "Usage: gtr {create|rm|cd|claude|cursor|prune|doctor|init} [--prefix PREFIX] [--username USERNAME] [--editor EDITOR] [--no-open] [--no-install] [--base BRANCH] <name>"; return 1; }

  # Check for command-specific flags before parsing global flags
  local fix_mode="false"
  local force_mode="false"
  local init_doctor="false"
  local init_fix="false"
  
  if [[ "$cmd" == "doctor" ]]; then
    for arg in "$@"; do
      if [[ "$arg" == "--fix" ]]; then
        fix_mode="true"
      elif [[ "$arg" == "--force" ]]; then
        force_mode="true"
      fi
    done
  elif [[ "$cmd" == "init" ]]; then
    for arg in "$@"; do
      if [[ "$arg" == "--doctor" ]]; then
        init_doctor="true"
      elif [[ "$arg" == "--fix" ]]; then
        init_fix="true"
      fi
    done
  fi

  # Check for help flags in arguments for idea command before parsing global flags
  if [[ "$cmd" == "i" || "$cmd" == "idea" ]]; then
    for arg in "$@"; do
      if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
        # Set up args for idea command and call it directly
        _GTR_ARGS=("$@")
        export _GTR_ARGS
        gtr_idea
        return 0
      fi
    done
  fi

  # Parse global flags
  _gtr_parse_global_flags "$@"
  
  # Export command-specific modes
  if [[ "$cmd" == "doctor" ]]; then
    export _GTR_FIX_MODE="$fix_mode"
    export _GTR_FORCE_MODE="$force_mode"
  elif [[ "$cmd" == "init" ]]; then
    export _GTR_INIT_DOCTOR="$init_doctor"
    export _GTR_INIT_FIX="$init_fix"
  fi
  
  # Dispatch to appropriate command
  case "$cmd" in
    c|create)
      gtr_create
      ;;
    rm|remove)
      gtr_remove
      ;;
    cd)
      gtr_cd
      ;;
    l|ls|list)
      gtr_list
      ;;
    i|idea)
      gtr_idea
      ;;
    claude)
      gtr_claude
      ;;
    cursor)
      gtr_cursor
      ;;
    prune)
      gtr_prune
      ;;
    doctor)
      gtr_doctor
      ;;
    init)
      gtr_init
      ;;
    *)
      echo "Unknown sub-command: $cmd (use create, rm, cd, idea, claude, cursor, prune, doctor, init)"; return 1;;
  esac
}

# If this file is executed directly (not sourced), run the dispatcher
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  gtr "$@"
fi
