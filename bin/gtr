#!/bin/bash

# gtr - Git worktree helper
# Modular entry point that sources all required modules
# ref: https://medium.com/@dtunai/mastering-git-worktrees-with-claude-code-for-parallel-development-workflow-41dc91e645fe

# Get the directory containing this script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$(dirname "$SCRIPT_DIR")/lib"

# Source all modules in dependency order
source_module() {
  local module="$1"
  if [[ -f "$LIB_DIR/$module" ]]; then
    source "$LIB_DIR/$module"
  else
    echo "Error: Cannot find module $module at $LIB_DIR/$module" >&2
    exit 1
  fi
}

# Source modules in dependency order (least dependent first)
source_module "gtr-core.sh"     # Core utilities and constants
source_module "gtr-ui.sh"       # User interaction
source_module "gtr-config.sh"   # Configuration management (depends on gtr-ui.sh)
source_module "gtr-files.sh"    # File operations (depends on gtr-config.sh, gtr-ui.sh)
source_module "gtr-hooks.sh"    # Hook execution (depends on gtr-core.sh)
source_module "gtr-git.sh"      # Git operations (depends on gtr-core.sh, gtr-config.sh, gtr-files.sh, gtr-ui.sh, gtr-hooks.sh)
source_module "gtr-commands.sh" # Command implementations (depends on all above)

# Main gtr function - dispatches to appropriate sub-commands
gtr() {
  local cmd="$1"
  local git_root=""

  # Handle --git-root option first
  if [[ "$cmd" == --git-root=* ]]; then
    git_root="${cmd#--git-root=}"
    shift
    cmd="$1"
  fi

  # Change to git root directory if specified
  if [[ -n "$git_root" ]]; then
    if [[ ! -d "$git_root" ]]; then
      echo "Error: Directory does not exist: $git_root" >&2
      return 1
    fi
    if [[ ! -d "$git_root/.git" ]]; then
      echo "Error: Directory is not a git repository: $git_root" >&2
      return 1
    fi
    cd "$git_root" || { echo "Error: Cannot change to directory: $git_root" >&2; return 1; }
  fi

  # Handle version/help flags before parsing other arguments
  if [[ "$cmd" == "--version" || "$cmd" == "-v" ]]; then
    _gtr_print_version
    return 0
  fi

  # Handle help flag before parsing other arguments
  if [[ "$cmd" == "--help" || "$cmd" == "-h" ]]; then
    _gtr_show_help
    return 0
  fi

  shift || { echo "Usage: gtr {create|rm|cd|claude|cursor|prune|doctor|init} [--prefix PREFIX] [--username USERNAME] [--editor EDITOR] [--no-open] [--no-install] [--base BRANCH] <name>"; return 1; }

  # Check for command-specific flags before parsing global flags
  local fix_mode="false"
  local force_mode="false"
  local init_doctor="false"
  local init_fix="false"

  if [[ "$cmd" == "doctor" ]]; then
    for arg in "$@"; do
      if [[ "$arg" == "--fix" ]]; then
        fix_mode="true"
      elif [[ "$arg" == "--force" ]]; then
        force_mode="true"
      fi
    done
  elif [[ "$cmd" == "init" ]]; then
    for arg in "$@"; do
      if [[ "$arg" == "--doctor" ]]; then
        init_doctor="true"
      elif [[ "$arg" == "--fix" ]]; then
        init_fix="true"
      fi
    done
  fi

  # Parse global flags
  _gtr_parse_global_flags "$@"

  # Export command-specific modes
  if [[ "$cmd" == "doctor" ]]; then
    export _GTR_FIX_MODE="$fix_mode"
    export _GTR_FORCE_MODE="$force_mode"
  elif [[ "$cmd" == "init" ]]; then
    export _GTR_INIT_DOCTOR="$init_doctor"
    export _GTR_INIT_FIX="$init_fix"
  fi

  # Dispatch to appropriate command
  case "$cmd" in
    c|create)
      gtr_create
      ;;
    rm|remove)
      gtr_remove
      ;;
    cd)
      gtr_cd
      ;;
    l|ls|list)
      gtr_list
      ;;
    i|idea)
      gtr_idea
      ;;
    claude)
      gtr_claude
      ;;
    cursor)
      gtr_cursor
      ;;
    prune)
      gtr_prune
      ;;
    doctor)
      gtr_doctor
      ;;
    init)
      gtr_init
      ;;
    *)
      echo "Unknown sub-command: $cmd (use create, rm, cd, idea, claude, cursor, prune, doctor, init)"; return 1;;
  esac
}

# If this file is executed directly (not sourced), run the dispatcher
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  gtr "$@"
fi