name: Bump Homebrew Formula

on:
  push:
    branches: [ main, master ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to bump (e.g., v0.1.0). Leave empty to use the latest release tag."
        required: false
        type: string
      dry_run:
        description: "If true, open a PR with a -dryrun suffix for safe testing."
        required: false
        default: "false"
        type: choice
        options: ["false", "true"]

permissions:
  contents: read
  pull-requests: write

jobs:
  bump:
    runs-on: macos-latest
    env:
      # ---- Customize these if your tap or formula path differ ----
      TAP_OWNER: ${{ vars.TAP_OWNER || 'ryanwjackson' }}
      TAP_REPO:  ${{ vars.TAP_REPO  || 'homebrew-tap' }}
      FORMULA_PATH: ${{ vars.FORMULA_PATH || 'Formula/gtr.rb' }}
      # ------------------------------------------------------------
    steps:
      - name: Checkout (handy if you later read files)
        uses: actions/checkout@v4

      - name: Check for release tag in commit
        id: check_release
        shell: bash
        run: |
          set -euo pipefail

          # For tag pushes, use the pushed tag directly
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            TAG="${{ github.ref_name }}"
            echo "Using pushed tag: $TAG"
            echo "tag=$TAG" >> "$GITHUB_OUTPUT"
            echo "should_run=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # For workflow_dispatch, use the provided tag or find latest release
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ -n "${{ github.event.inputs.tag }}" ]]; then
              TAG="${{ github.event.inputs.tag }}"
              echo "Using manually specified tag: $TAG"
            else
              # Find the latest release tag
              TAG=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null || echo "")
              if [[ -z "$TAG" ]]; then
                echo "No releases found and no tag specified"
                exit 1
              fi
              echo "Using latest release tag: $TAG"
            fi
            echo "tag=$TAG" >> "$GITHUB_OUTPUT"
            echo "should_run=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # For push events, check if the commit contains a release tag
          echo "Checking if commit contains a release tag..."
          
          # Get the commit message and check for version tags
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "Commit message: $COMMIT_MSG"
          
          # Look for version tags in the commit message (e.g., "Release v1.2.3" or "v1.2.3")
          if echo "$COMMIT_MSG" | grep -E '\bv[0-9]+\.[0-9]+\.[0-9]+\b' >/dev/null; then
            # Extract the version tag from commit message
            TAG=$(echo "$COMMIT_MSG" | grep -oE '\bv[0-9]+\.[0-9]+\.[0-9]+\b' | head -1)
            echo "Found release tag in commit message: $TAG"
            echo "tag=$TAG" >> "$GITHUB_OUTPUT"
            echo "should_run=true" >> "$GITHUB_OUTPUT"
          else
            # Check if any tags were pushed in this commit
            TAGS=$(git tag --points-at HEAD | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || true)
            if [[ -n "$TAGS" ]]; then
              TAG=$(echo "$TAGS" | head -1)
              echo "Found release tag pushed with commit: $TAG"
              echo "tag=$TAG" >> "$GITHUB_OUTPUT"
              echo "should_run=true" >> "$GITHUB_OUTPUT"
            else
              echo "No release tag found in commit or pushed tags"
              echo "should_run=false" >> "$GITHUB_OUTPUT"
            fi
          fi

      - name: Skip if no release tag found
        if: steps.check_release.outputs.should_run != 'true'
        run: |
          echo "No release tag found in this commit. Skipping Homebrew bump."
          echo "To trigger a release, include a version tag (e.g., v1.2.3) in your commit message or push a release tag."
          exit 0

      - name: Ensure GH CLI is authenticated
        env:
          GH_TOKEN: ${{ secrets.HOMEBREW_BUMP_TOKEN }}
        run: gh auth status

      - name: Compute tarball URL and SHA256
        if: steps.check_release.outputs.should_run == 'true'
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          # Use the tag detected in the previous step
          TAG="${{ steps.check_release.outputs.tag }}"
          REPO="${{ github.repository }}"  # should be ryanwjackson/gtr
          TARBALL="https://github.com/${REPO}/archive/refs/tags/${TAG}.tar.gz"
          echo "Tarball: $TARBALL"

          curl -L "$TARBALL" -o source.tar.gz
          SHA256="$(shasum -a 256 source.tar.gz | awk '{print $1}')"

          echo "tag=$TAG"         >> "$GITHUB_OUTPUT"
          echo "tarball=$TARBALL" >> "$GITHUB_OUTPUT"
          echo "sha256=$SHA256"   >> "$GITHUB_OUTPUT"

      - name: Rebuild tarball with injected version & upload asset
        if: steps.check_release.outputs.should_run == 'true'
        id: pack
        env:
          GH_TOKEN: ${{ secrets.HOMEBREW_BUMP_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.meta.outputs.tag }}"

          # Debug: verify we have a valid tag
          if [[ -z "$TAG" ]]; then
            echo "ERROR: TAG is empty"
            exit 1
          fi
          echo "Using tag: $TAG"

          # Unpack original source
          rm -rf src
          mkdir -p src
          tar -xzf source.tar.gz -C src --strip-components=1

          # Inject version into script
          if command -v gsed >/dev/null 2>&1; then
            gsed -i 's/@VERSION@/'"$TAG"'/g' src/bin/gtr
          else
            sed -i '' 's/@VERSION@/'"$TAG"'/g' src/bin/gtr
          fi

          # Repack
          TAR="gtr-${TAG}.tar.gz"
          tar -czf "$TAR" -C src .

          # Compute SHA256
          SHA256="$(shasum -a 256 "$TAR" | awk '{print $1}')"
          echo "sha256=$SHA256" >> "$GITHUB_OUTPUT"
          echo "asset=$TAR" >> "$GITHUB_OUTPUT"

          # Upload asset to the release
          gh release upload "$TAG" "$TAR" --clobber

          # Get asset URL (browser download URL)
          ASSET_URL="$(gh release view "$TAG" --json assets -q '.assets[] | select(.name=="'"$TAR"'") | .url')"
          echo "asset_url=$ASSET_URL" >> "$GITHUB_OUTPUT"

      - name: Clone tap and bump formula
        if: steps.check_release.outputs.should_run == 'true'
        env:
          GH_TOKEN: ${{ secrets.HOMEBREW_BUMP_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          gh repo clone "$TAP_OWNER/$TAP_REPO" tap
          cd tap

          # Determine dry-run suffix and branch name
          DRY="${{ github.event.inputs.dry_run || 'false' }}"
          SUFFIX=""
          if [[ "$DRY" == "true" ]]; then SUFFIX="-dryrun"; fi

          # Use timestamp to make branch names unique for retries/re-runs
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BRANCH="bump-gtr-${{ steps.meta.outputs.tag }}-${TIMESTAMP}$SUFFIX"

          # Clean up old bump branches for this version (keep last 3)
          echo "Cleaning up old bump branches for version ${{ steps.meta.outputs.tag }}..."
          OLD_BRANCHES=$(gh api repos/"$TAP_OWNER"/"$TAP_REPO"/branches --jq '.[] | select(.name | startswith("bump-gtr-${{ steps.meta.outputs.tag }}-")) | .name' | sort -r | tail -n +4)
          for old_branch in $OLD_BRANCHES; do
            echo "Deleting old branch: $old_branch"
            gh api repos/"$TAP_OWNER"/"$TAP_REPO"/git/refs/heads/"$old_branch" -X DELETE 2>/dev/null || echo "Failed to delete $old_branch, continuing..."
          done

          git checkout -b "$BRANCH"

          # Configure git identity (can also set via repo variables)
          git config user.name  "${{ vars.GIT_USER_NAME  || 'github-actions[bot]' }}"
          git config user.email "${{ vars.GIT_USER_EMAIL || '41898282+github-actions[bot]@users.noreply.github.com' }}"

          # Configure git to use GH CLI credentials for HTTPS pushes
          gh auth setup-git

          # In-place edit with Perl (portable across BSD/GNU)
          NEW_URL="${{ steps.pack.outputs.asset_url }}"
          NEW_SHA="${{ steps.pack.outputs.sha256 }}"
          URL="$NEW_URL" SHA="$NEW_SHA" perl -0777 -i -pe 's|^  url ".*"|  url "$ENV{URL}"|m; s|^  sha256 ".*"|  sha256 "$ENV{SHA}"|m' "$FORMULA_PATH"

          echo "Diff:"
          git --no-pager diff -- "$FORMULA_PATH" || true

          # If no changes were made, exit successfully (nothing to bump)
          if git diff --quiet -- "$FORMULA_PATH"; then
            echo "No changes detected in $FORMULA_PATH; skipping commit and PR."
            exit 0
          fi

          git add "$FORMULA_PATH"
          git commit -m "gtr: bump to ${{ steps.meta.outputs.tag }}$SUFFIX"
          git push -u origin "$BRANCH"

          # Open a PR targeting the tap's default branch
          gh pr create \
            --title "Bump gtr to ${{ steps.meta.outputs.tag }}$SUFFIX" \
            --body  "Automated bump (dry_run=${DRY}): update URL and SHA256 for ${{ steps.meta.outputs.tag }}." \
            --fill

          # If not a dry run, enable auto-merge so it merges once checks pass
          if [[ "$DRY" != "true" ]]; then
            # Approve the PR from the bot account to satisfy branch protections requiring approval
            gh pr review --approve || echo "Approve failed (may not be required). Proceeding to set auto-merge."
            # This targets the PR associated with the current branch by default
            # Use your preferred strategy: --squash (default here) or --merge/--rebase
            gh pr merge --auto --squash --delete-branch || {
              echo "Auto-merge failed or not enabled on the repository. Leaving PR open.";
            }
          else
            echo "Dry run enabled; skipping auto-merge.";
          fi

      # Optional: uncomment to lint the formula in CI for extra safety
      # - name: Brew audit (optional)
      #   shell: bash
      #   run: |
      #     set -euo pipefail
      #     brew update
      #     brew audit --strict --new-formula "tap/$FORMULA_PATH"